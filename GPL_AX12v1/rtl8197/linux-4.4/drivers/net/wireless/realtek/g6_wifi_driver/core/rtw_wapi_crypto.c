#if defined(CONFIG_RTL_CFG80211_WAPI_SUPPORT)

#include <linux/unistd.h>
#include <linux/etherdevice.h>
#include <drv_types.h>
#include <rtw_ap_wapi.h>
#define WAPI_ENCRYPT 0
#define WAPI_DECRYPT 1
//#define WAPI_GCM_SM4_DEBUG

#ifdef WAPI_GCM_SM4_DEBUG
#define TEST_TABLE_NUM 15
/*******************************************table0************************************************/
u8 key0[]={
0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x04, 0x00, 0x05, 0x00, 0x06, 0x00, 0x07, 0x00, 0x08
};

u8 iv0[]={
0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36
};

u8 aad0[]={
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x03, 0x7F, 0xFF, 0xFF, 0xFE, 0x89, 0x2C, 0x38, 0x00, 0x00, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36
};

u8 pdata0[]={
0x08, 0x06, 0x00, 0x01, 0x08, 0x00, 0x06, 0x04, 0x00, 0x01, 0x00, 0x03, 0x7F, 0xFF, 0xFF, 0xFE,
0xC0, 0xA8, 0x14, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xA8, 0x14, 0x0D, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

u8 cdata0[]={
0x0A, 0x59, 0x91, 0xA6, 0x70, 0xDC, 0x0E, 0xA2, 0x6F, 0x84, 0xE4, 0x55, 0xA1, 0xC0, 0x61, 0x47,
0x8A, 0xA0, 0x9F, 0x2F, 0xBE, 0x90, 0x49, 0x46, 0x29, 0xBC, 0x58, 0xE7, 0x5B, 0xE5, 0xE9, 0x1D,
0xBC, 0x6D, 0x21, 0x49, 0xBC, 0x1F, 0xBA, 0xCA, 0xCA, 0xA9, 0x72, 0x2D, 0x61, 0x0F, 0xDE, 0x1D
};

u8 mictag0[]={
0x99, 0x20, 0xB1, 0xEB, 0xFB, 0x59, 0x02, 0x5F, 0x0E, 0xBA, 0x77, 0x8C, 0xF5, 0x9A, 0x5C, 0xC8
};

/*******************************************table1************************************************/
u8 key1[]={
0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x04, 0x00, 0x05, 0x00, 0x06, 0x00, 0x07, 0x00, 0x08
};

u8 iv1[]={
0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36
};

u8 aad1[]={
0x08, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x0C, 0x43, 0x35, 0xA1, 0xDD, 0x00, 0x00,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x24
};

u8 pdata1[]={
0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00, 0x08, 0x06, 0x00, 0x01, 0x08, 0x00, 0x06, 0x04, 0x00, 0x01,
0x00, 0x0C, 0x43, 0x35, 0xA1, 0xDD, 0x0A, 0x0A, 0x0A, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x0A, 0x0A, 0x0A, 0xFE
};

u8 cdata1[]={
0xA8, 0xF5, 0x92, 0xA7, 0x78, 0xDC, 0x00, 0xA0, 0x6F, 0x84, 0xEC, 0x56, 0xD8, 0x3B, 0x9E, 0xB8,
0x4A, 0x04, 0xC8, 0x10, 0x1F, 0x4D, 0x43, 0x4C, 0x23, 0xDB, 0x98, 0x4F, 0x4F, 0xE8, 0xE9, 0x1D,
0xB6, 0x67, 0x2B, 0xB7
};

u8 mictag1[]={
0x1F, 0xF8, 0x19, 0x49, 0x16, 0xA0, 0xA0, 0x58, 0xDA, 0x6E, 0x97, 0x8F, 0x52, 0xBF, 0x24, 0x7C
};
/*****************************************table2*********************************************/
u8 key2[]={
0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x04, 0x00, 0x05, 0x00, 0x06, 0x00, 0x07, 0x00, 0x08
};
u8 iv2[]={
0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36
};
u8 aad2[]={
0x88, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x0C, 0x43, 0x35, 0xA1, 0xDD, 0x00, 0x00,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00,
0x00, 0x24
};
u8 pdata2[]={
0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00, 0x08, 0x06, 0x00, 0x01, 0x08, 0x00, 0x06, 0x04, 0x00, 0x01,
0x00, 0x0C, 0x43, 0x35, 0xA1, 0xDD, 0x0A, 0x0A, 0x0A, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x0A, 0x0A, 0x0A, 0xFE
};
u8 cdata2[]={
0xA8, 0xF5, 0x92, 0xA7, 0x78, 0xDC, 0x00, 0xA0, 0x6F, 0x84, 0xEC, 0x56, 0xD8, 0x3B, 0x9E, 0xB8,
0x4A, 0x04, 0xC8, 0x10, 0x1F, 0x4D, 0x43, 0x4C, 0x23, 0xDB, 0x98, 0x4F, 0x4F, 0xE8, 0xE9, 0x1D,
0xB6, 0x67, 0x2B, 0xB7
};
u8 mictag2[]={
0x7C, 0x3B, 0x09, 0x49, 0x1E, 0x21, 0x36, 0x7A, 0x93, 0xA0, 0x82, 0xE8, 0x52, 0x7C, 0xA8, 0x4F
};

/*****************************************table3*********************************************/
u8 key3[]={
0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16
};
u8 iv3[]={
0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x59, 0x40, 0x59, 0x37
};
u8 aad3[]={
0x08, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x0C, 0x43, 0x35, 0xA1, 0xDD, 0x00, 0x00,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x50
};
u8 pdata3[]={
0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x45, 0x00, 0x01, 0x48, 0x12, 0xAA, 0x00, 0x00,
0x80, 0x11, 0x12, 0x8B, 0x0A, 0x0A, 0x0A, 0x67, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x44, 0x00, 0x43,
0x01, 0x34, 0x4C, 0xE0, 0x01, 0x01, 0x06, 0x00, 0xE3, 0xC3, 0xBC, 0x98, 0x00, 0x00, 0x00, 0x00,
0x0A, 0x0A, 0x0A, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x0C, 0x43, 0x35, 0xA1, 0xDD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x63, 0x82, 0x53, 0x63, 0x35, 0x01, 0x08, 0x3D, 0x07, 0x01, 0x00, 0x0C, 0x43, 0x35, 0xA1, 0xDD,
0x0C, 0x0D, 0x48, 0x50, 0x36, 0x32, 0x30, 0x30, 0x57, 0x69, 0x6E, 0x37, 0x2D, 0x50, 0x43, 0x3C,
0x08, 0x4D, 0x53, 0x46, 0x54, 0x20, 0x35, 0x2E, 0x30, 0x37, 0x0D, 0x01, 0x0F, 0x03, 0x06, 0x2C,
0x2E, 0x2F, 0x1F, 0x21, 0x79, 0xF9, 0x2B, 0xFC, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
u8 cdata3[]={
0x92, 0x40, 0x0A, 0x40, 0xC8, 0x96, 0x41, 0x50, 0xAE, 0xC2, 0x63, 0x24, 0xB0, 0x8C, 0xF5, 0x2A,
0xEA, 0xDA, 0x2E, 0x6B, 0xC3, 0x22, 0xAA, 0xF7, 0x24, 0x45, 0x01, 0x80, 0x1D, 0x40, 0xDC, 0xF2,
0xB0, 0xB0, 0xB0, 0xC1, 0x7A, 0xE4, 0x38, 0x1C, 0x16, 0x24, 0x67, 0x33, 0xFC, 0x9C, 0xF3, 0xD6,
0x0E, 0xDF, 0x25, 0x0F, 0x87, 0xCE, 0x7C, 0x90, 0xD3, 0x97, 0xBE, 0x41, 0xF6, 0x8C, 0x0F, 0x57,
0x2A, 0x9B, 0x3D, 0x72, 0x14, 0xF5, 0x9F, 0x1B, 0xCD, 0xF3, 0xA1, 0x8B, 0xF7, 0x03, 0x09, 0x5C,
0xDD, 0x00, 0xC4, 0x7A, 0xDB, 0xC3, 0x48, 0x96, 0x92, 0x20, 0x83, 0xC5, 0x7C, 0xB7, 0xBD, 0xFE,
0x6F, 0xBF, 0x00, 0x6C, 0x8A, 0x76, 0x48, 0xA1, 0x6D, 0x33, 0x41, 0xC8, 0x95, 0x6B, 0x59, 0xA0,
0xB6, 0xC3, 0x6B, 0x81, 0xFE, 0x47, 0x60, 0x9A, 0xFD, 0x87, 0x18, 0x9C, 0xC8, 0xBF, 0xF2, 0xAE,
0x61, 0x8E, 0x6E, 0xF6, 0x08, 0xE2, 0xCA, 0xD5, 0x37, 0xE2, 0x08, 0xA1, 0x54, 0xFB, 0xBC, 0x4E,
0xD8, 0x64, 0x0D, 0x32, 0x09, 0x77, 0x34, 0x5F, 0x0A, 0x70, 0x9E, 0xB7, 0x08, 0x2C, 0xA8, 0x36,
0xD4, 0x10, 0x5A, 0xF9, 0x32, 0x82, 0xC6, 0xAB, 0x65, 0x9D, 0xE9, 0xD1, 0x3B, 0x93, 0x52, 0x48,
0x48, 0x3A, 0x8F, 0x6A, 0x0B, 0x22, 0x95, 0x0F, 0x76, 0xE5, 0xBF, 0xB3, 0x7C, 0x05, 0x53, 0x70,
0x9D, 0xC5, 0x95, 0xEE, 0xB0, 0xC8, 0x32, 0x1F, 0xC3, 0xBE, 0xB4, 0xC8, 0xA2, 0x23, 0x95, 0x9F,
0x76, 0x72, 0x77, 0x38, 0x25, 0x2E, 0x03, 0x9D, 0xAE, 0x97, 0xBF, 0xBE, 0x23, 0xEE, 0x14, 0x34,
0xCB, 0xC6, 0x3D, 0x73, 0xB6, 0x53, 0x4B, 0x41, 0x2B, 0x0B, 0xDE, 0xEB, 0x65, 0x44, 0x3E, 0x92,
0xBC, 0x07, 0xDF, 0x57, 0xD4, 0x47, 0x20, 0xC4, 0x3B, 0xDB, 0x38, 0x49, 0xE1, 0x68, 0x31, 0x03,
0xE7, 0x59, 0x8A, 0x86, 0x7D, 0xC0, 0x3C, 0x29, 0xDC, 0x9B, 0x2B, 0x51, 0xD7, 0x05, 0xF0, 0x9A,
0xEE, 0x90, 0xB2, 0x43, 0x42, 0xC5, 0x80, 0x0D, 0xEB, 0xE0, 0x6C, 0xE3, 0x0E, 0xC1, 0xB9, 0x40,
0x2D, 0x69, 0xC0, 0x59, 0xB6, 0x24, 0xB7, 0x11, 0x7B, 0x05, 0x27, 0x46, 0x17, 0x48, 0xB8, 0x42,
0x89, 0xC8, 0x02, 0xA7, 0xF8, 0xFB, 0x47, 0xE9, 0x9B, 0x45, 0xB8, 0x50, 0x3D, 0x74, 0x94, 0xC3,
0xEF, 0xDA, 0x27, 0xF3, 0xE3, 0xD2, 0xB2, 0xC1, 0x4B, 0x11, 0x5B, 0x38, 0x91, 0x76, 0x58, 0x72
};
u8 mictag3[]={
0x82, 0xE4, 0x4C, 0x4E, 0xBC, 0x16, 0x99, 0x43, 0x52, 0x24, 0x0F, 0xFE, 0xDD, 0xC0, 0xA0, 0x1D
};
/*****************************************table4*********************************************/
u8 key4[]={
0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16
};
u8 iv4[]={
0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x59, 0x40, 0x59, 0x37
};
u8 aad4[]={
0x88, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x0C, 0x43, 0x35, 0xA1, 0xDD, 0x00, 0x00,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
0x01, 0x50
};
u8 pdata4[]={
0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x45, 0x00, 0x01, 0x48, 0x12, 0xAA, 0x00, 0x00,
0x80, 0x11, 0x12, 0x8B, 0x0A, 0x0A, 0x0A, 0x67, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x44, 0x00, 0x43,
0x01, 0x34, 0x4C, 0xE0, 0x01, 0x01, 0x06, 0x00, 0xE3, 0xC3, 0xBC, 0x98, 0x00, 0x00, 0x00, 0x00,
0x0A, 0x0A, 0x0A, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x0C, 0x43, 0x35, 0xA1, 0xDD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x63, 0x82, 0x53, 0x63, 0x35, 0x01, 0x08, 0x3D, 0x07, 0x01, 0x00, 0x0C, 0x43, 0x35, 0xA1, 0xDD,
0x0C, 0x0D, 0x48, 0x50, 0x36, 0x32, 0x30, 0x30, 0x57, 0x69, 0x6E, 0x37, 0x2D, 0x50, 0x43, 0x3C,
0x08, 0x4D, 0x53, 0x46, 0x54, 0x20, 0x35, 0x2E, 0x30, 0x37, 0x0D, 0x01, 0x0F, 0x03, 0x06, 0x2C,
0x2E, 0x2F, 0x1F, 0x21, 0x79, 0xF9, 0x2B, 0xFC, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
u8 cdata4[]={
0x92, 0x40, 0x0A, 0x40, 0xC8, 0x96, 0x41, 0x50, 0xAE, 0xC2, 0x63, 0x24, 0xB0, 0x8C, 0xF5, 0x2A,
0xEA, 0xDA, 0x2E, 0x6B, 0xC3, 0x22, 0xAA, 0xF7, 0x24, 0x45, 0x01, 0x80, 0x1D, 0x40, 0xDC, 0xF2,
0xB0, 0xB0, 0xB0, 0xC1, 0x7A, 0xE4, 0x38, 0x1C, 0x16, 0x24, 0x67, 0x33, 0xFC, 0x9C, 0xF3, 0xD6,
0x0E, 0xDF, 0x25, 0x0F, 0x87, 0xCE, 0x7C, 0x90, 0xD3, 0x97, 0xBE, 0x41, 0xF6, 0x8C, 0x0F, 0x57,
0x2A, 0x9B, 0x3D, 0x72, 0x14, 0xF5, 0x9F, 0x1B, 0xCD, 0xF3, 0xA1, 0x8B, 0xF7, 0x03, 0x09, 0x5C,
0xDD, 0x00, 0xC4, 0x7A, 0xDB, 0xC3, 0x48, 0x96, 0x92, 0x20, 0x83, 0xC5, 0x7C, 0xB7, 0xBD, 0xFE,
0x6F, 0xBF, 0x00, 0x6C, 0x8A, 0x76, 0x48, 0xA1, 0x6D, 0x33, 0x41, 0xC8, 0x95, 0x6B, 0x59, 0xA0,
0xB6, 0xC3, 0x6B, 0x81, 0xFE, 0x47, 0x60, 0x9A, 0xFD, 0x87, 0x18, 0x9C, 0xC8, 0xBF, 0xF2, 0xAE,
0x61, 0x8E, 0x6E, 0xF6, 0x08, 0xE2, 0xCA, 0xD5, 0x37, 0xE2, 0x08, 0xA1, 0x54, 0xFB, 0xBC, 0x4E,
0xD8, 0x64, 0x0D, 0x32, 0x09, 0x77, 0x34, 0x5F, 0x0A, 0x70, 0x9E, 0xB7, 0x08, 0x2C, 0xA8, 0x36,
0xD4, 0x10, 0x5A, 0xF9, 0x32, 0x82, 0xC6, 0xAB, 0x65, 0x9D, 0xE9, 0xD1, 0x3B, 0x93, 0x52, 0x48,
0x48, 0x3A, 0x8F, 0x6A, 0x0B, 0x22, 0x95, 0x0F, 0x76, 0xE5, 0xBF, 0xB3, 0x7C, 0x05, 0x53, 0x70,
0x9D, 0xC5, 0x95, 0xEE, 0xB0, 0xC8, 0x32, 0x1F, 0xC3, 0xBE, 0xB4, 0xC8, 0xA2, 0x23, 0x95, 0x9F,
0x76, 0x72, 0x77, 0x38, 0x25, 0x2E, 0x03, 0x9D, 0xAE, 0x97, 0xBF, 0xBE, 0x23, 0xEE, 0x14, 0x34,
0xCB, 0xC6, 0x3D, 0x73, 0xB6, 0x53, 0x4B, 0x41, 0x2B, 0x0B, 0xDE, 0xEB, 0x65, 0x44, 0x3E, 0x92,
0xBC, 0x07, 0xDF, 0x57, 0xD4, 0x47, 0x20, 0xC4, 0x3B, 0xDB, 0x38, 0x49, 0xE1, 0x68, 0x31, 0x03,
0xE7, 0x59, 0x8A, 0x86, 0x7D, 0xC0, 0x3C, 0x29, 0xDC, 0x9B, 0x2B, 0x51, 0xD7, 0x05, 0xF0, 0x9A,
0xEE, 0x90, 0xB2, 0x43, 0x42, 0xC5, 0x80, 0x0D, 0xEB, 0xE0, 0x6C, 0xE3, 0x0E, 0xC1, 0xB9, 0x40,
0x2D, 0x69, 0xC0, 0x59, 0xB6, 0x24, 0xB7, 0x11, 0x7B, 0x05, 0x27, 0x46, 0x17, 0x48, 0xB8, 0x42,
0x89, 0xC8, 0x02, 0xA7, 0xF8, 0xFB, 0x47, 0xE9, 0x9B, 0x45, 0xB8, 0x50, 0x3D, 0x74, 0x94, 0xC3,
0xEF, 0xDA, 0x27, 0xF3, 0xE3, 0xD2, 0xB2, 0xC1, 0x4B, 0x11, 0x5B, 0x38, 0x91, 0x76, 0x58, 0x72
};
u8 mictag4[]={
0xE3, 0x92, 0x5B, 0x82, 0x60, 0x98, 0xED, 0x27, 0xE1, 0xFE, 0x53, 0x8B, 0xF5, 0x70, 0xD4, 0xCF
};
/*****************************************table5*********************************************/
u8 key5[]={
0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5
};
u8 iv5[]={
0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x66, 0x5C, 0x36, 0x50, 0x41, 0x52, 0x32
};
u8 aad5[]={
0x08, 0x43, 0x00, 0x0C, 0x43, 0x35, 0xA1, 0xDD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x22, 0x33, 0x44, 0x55, 0x66, 0x00, 0x00, 0x00, 0x24
};
u8 pdata5[]={
0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00, 0x08, 0x06, 0x00, 0x01, 0x08, 0x00, 0x06, 0x04, 0x00, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x0A, 0x0A, 0x0A, 0xFE, 0x00, 0x0C, 0x43, 0x35, 0xA1, 0xDD,
0x0A, 0x0A, 0x0A, 0x67
};
u8 cdata5[]={
0x55, 0xAB, 0x14, 0xE7, 0x92, 0xF9, 0xD3, 0x42, 0x5E, 0xC8, 0x61, 0xEC, 0x9B, 0x1C, 0xE0, 0x0B,
0xDA, 0x70, 0x58, 0x63, 0xCC, 0xD3, 0x67, 0xD0, 0x5C, 0x2A, 0xAB, 0x25, 0x69, 0x16, 0x48, 0x9E,
0x09, 0x16, 0x84, 0x9D
};
u8 mictag5[]={
0xA7, 0x65, 0x88, 0x12, 0xF8, 0xA7, 0x68, 0x3E, 0x12, 0x3B, 0xBF, 0x10, 0x7F, 0x97, 0xA7, 0x17
};
/*****************************************table6*********************************************/
u8 key6[]={
0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5
};
u8 iv6[]={
0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x66, 0x5C, 0x36, 0x50, 0x41, 0x52, 0x32
};
u8 aad6[]={
0x88, 0x43, 0x00, 0x0C, 0x43, 0x35, 0xA1, 0xDD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x22, 0x33, 0x44, 0x55, 0x66, 0x05, 0x00, 0x00, 0x00,
0x00, 0x24
};
u8 pdata6[]={
0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00, 0x08, 0x06, 0x00, 0x01, 0x08, 0x00, 0x06, 0x04, 0x00, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x0A, 0x0A, 0x0A, 0xFE, 0x00, 0x0C, 0x43, 0x35, 0xA1, 0xDD,
0x0A, 0x0A, 0x0A, 0x67
};
u8 cdata6[]={
0x55, 0xAB, 0x14, 0xE7, 0x92, 0xF9, 0xD3, 0x42, 0x5E, 0xC8, 0x61, 0xEC, 0x9B, 0x1C, 0xE0, 0x0B,
0xDA, 0x70, 0x58, 0x63, 0xCC, 0xD3, 0x67, 0xD0, 0x5C, 0x2A, 0xAB, 0x25, 0x69, 0x16, 0x48, 0x9E,
0x09, 0x16, 0x84, 0x9D
};
u8 mictag6[]={
0x66, 0x94, 0xBB, 0x1B, 0x59, 0xF3, 0x9B, 0x31, 0x73, 0x08, 0xCA, 0xF8, 0xEB, 0x73, 0xED, 0x46
};

/*****************************************table7*********************************************/
u8 key7[]={
0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5
};
u8 iv7[]={
0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5D, 0x32
};
u8 aad7[]={
0x88, 0x41, 0x00, 0x14, 0x72, 0x03, 0x0C, 0x77, 0x44, 0x94, 0xFC, 0xF3, 0x1E, 0x64, 0x00, 0x00,
0x00, 0x14, 0x72, 0x03, 0x0C, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x56
};
u8 pdata7[]={
0x1B, 0x78, 0x1A, 0x9C, 0x61, 0xF8, 0x63, 0x37, 0xA1, 0x06, 0x96, 0xBD, 0x67, 0x80, 0x25, 0xD4,
0x64, 0xF5, 0x24, 0x90, 0x3A, 0x4A, 0x47, 0xC6, 0x90, 0xC0, 0x6D, 0x49, 0x2D, 0x12, 0x40, 0x16,
0x5A, 0xE4, 0xAC, 0x32, 0xE5, 0x09, 0xF4, 0x65, 0x78, 0xBB, 0x7A, 0x78, 0x37, 0xE8, 0x23, 0x7C,
0x47, 0x2D, 0xFC, 0x2C, 0xF7, 0x9E, 0x10, 0xFF, 0x5A, 0xB6, 0xE2, 0xFE, 0x94, 0xDC, 0x42, 0xE8,
0xEB, 0xAD, 0x20, 0xC1, 0x77, 0x20, 0x29, 0x14, 0xB9, 0xAF, 0xD7, 0x09, 0xD1, 0x90, 0xB7, 0x39,
0xBC, 0x21, 0xDB, 0xCC, 0xBF, 0x87
};
u8 cdata7[]={
0x7D, 0x99, 0x4A, 0xEE, 0xA6, 0xD4, 0x7A, 0x9B, 0x52, 0xCC, 0x9B, 0x35, 0xDA, 0xE9, 0x14, 0x20,
0x3D, 0x63, 0x9D, 0x1B, 0xBE, 0xE0, 0x17, 0xC2, 0xBE, 0xD9, 0xD9, 0x59, 0x42, 0x21, 0x61, 0x20,
0xB5, 0x68, 0xC8, 0x6E, 0xB9, 0x31, 0x84, 0x2E, 0x47, 0xE2, 0x13, 0xDA, 0x5F, 0xD5, 0x21, 0x8E,
0xBB, 0x82, 0x90, 0x57, 0xD2, 0xE9, 0xC9, 0xF8, 0x95, 0xAD, 0x51, 0x79, 0x08, 0x1B, 0x9C, 0x8D,
0x4E, 0x3B, 0x0F, 0xAC, 0xB0, 0xD3, 0xC9, 0xA3, 0x54, 0x1E, 0x95, 0xE1, 0xF7, 0x11, 0x42, 0x7C,
0x76, 0x58, 0xDA, 0x24, 0xAE, 0xCD
};
u8 mictag7[]={
0xC1, 0x9F, 0xFD, 0x2F, 0x5A, 0x9C, 0x41, 0xE5, 0xE8, 0x95, 0x45, 0x5E, 0x15, 0x94, 0xCE, 0x9A
};

/*****************************************table8*********************************************/
u8 key8[]={
0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5
};
u8 iv8[]={
0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5D, 0x32
};
u8 aad8[]={
0x88, 0x41, 0x00, 0x14, 0x72, 0x03, 0x0C, 0x77, 0x44, 0x94, 0xFC, 0xF3, 0x1E, 0x64, 0x00, 0x00,
0x00, 0x14, 0x72, 0x03, 0x0C, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
0x00, 0x56
};
u8 pdata8[]={
0x1B, 0x78, 0x1A, 0x9C, 0x61, 0xF8, 0x63, 0x37, 0xA1, 0x06, 0x96, 0xBD, 0x67, 0x80, 0x25, 0xD4,
0x64, 0xF5, 0x24, 0x90, 0x3A, 0x4A, 0x47, 0xC6, 0x90, 0xC0, 0x6D, 0x49, 0x2D, 0x12, 0x40, 0x16,
0x5A, 0xE4, 0xAC, 0x32, 0xE5, 0x09, 0xF4, 0x65, 0x78, 0xBB, 0x7A, 0x78, 0x37, 0xE8, 0x23, 0x7C,
0x47, 0x2D, 0xFC, 0x2C, 0xF7, 0x9E, 0x10, 0xFF, 0x5A, 0xB6, 0xE2, 0xFE, 0x94, 0xDC, 0x42, 0xE8,
0xEB, 0xAD, 0x20, 0xC1, 0x77, 0x20, 0x29, 0x14, 0xB9, 0xAF, 0xD7, 0x09, 0xD1, 0x90, 0xB7, 0x39,
0xBC, 0x21, 0xDB, 0xCC, 0xBF, 0x87
};
u8 cdata8[]={
0x7D, 0x99, 0x4A, 0xEE, 0xA6, 0xD4, 0x7A, 0x9B, 0x52, 0xCC, 0x9B, 0x35, 0xDA, 0xE9, 0x14, 0x20,
0x3D, 0x63, 0x9D, 0x1B, 0xBE, 0xE0, 0x17, 0xC2, 0xBE, 0xD9, 0xD9, 0x59, 0x42, 0x21, 0x61, 0x20,
0xB5, 0x68, 0xC8, 0x6E, 0xB9, 0x31, 0x84, 0x2E, 0x47, 0xE2, 0x13, 0xDA, 0x5F, 0xD5, 0x21, 0x8E,
0xBB, 0x82, 0x90, 0x57, 0xD2, 0xE9, 0xC9, 0xF8, 0x95, 0xAD, 0x51, 0x79, 0x08, 0x1B, 0x9C, 0x8D,
0x4E, 0x3B, 0x0F, 0xAC, 0xB0, 0xD3, 0xC9, 0xA3, 0x54, 0x1E, 0x95, 0xE1, 0xF7, 0x11, 0x42, 0x7C,
0x76, 0x58, 0xDA, 0x24, 0xAE, 0xCD
};
u8 mictag8[]={
0x3C, 0x35, 0xE3, 0xE3, 0x8D, 0x03, 0x7E, 0x9E, 0x4C, 0x18, 0x29, 0x25, 0x86, 0x3C, 0x7E, 0xA2
};
/*****************************************table9*********************************************/
u8 key9[]={
0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5
};
u8 iv9[]={
0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5D, 0x39
};
u8 aad9[]={
0x88, 0x41, 0x00, 0x14, 0x72, 0x03, 0x0C, 0x77, 0x44, 0x94, 0xFC, 0xF3, 0x1E, 0x64, 0x00, 0x00,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x34
};
u8 pdata9[]={
0xAF, 0x26, 0xDA, 0xA5, 0x41, 0xD2, 0x60, 0xF7, 0x39, 0x73, 0x02, 0xE1, 0xF1, 0x20, 0x72, 0x9E,
0x85, 0x67, 0x02, 0xC0, 0xD8, 0x98, 0x8F, 0x8D, 0x3E, 0x09, 0x42, 0x3F, 0x61, 0x26, 0x3A, 0xEB,
0x80, 0x0B, 0xD6, 0x87, 0xBA, 0xCD, 0x61, 0xC1, 0x4D, 0x07, 0x40, 0xB1, 0x3D, 0xFE, 0x38, 0x0B,
0x27, 0x5B, 0xD0, 0xA1
};
u8 cdata9[]={
0x83, 0xB6, 0x2B, 0xC2, 0x10, 0x3D, 0x6A, 0x02, 0xC4, 0x7B, 0x51, 0x38, 0x91, 0x20, 0x01, 0x2A,
0x35, 0x66, 0xB2, 0x28, 0x68, 0x44, 0xCE, 0x16, 0xD3, 0x65, 0xBA, 0x1F, 0xED, 0x0F, 0x55, 0xC5,
0x05, 0xDA, 0xB4, 0x78, 0x91, 0x6F, 0xDF, 0x2D, 0xE6, 0xFD, 0x29, 0x39, 0x44, 0x68, 0xBE, 0x72,
0x0B, 0x52, 0x2B, 0x09
};
u8 mictag9[]={
0xD6, 0xFA, 0x67, 0x05, 0xA6, 0x17, 0x09, 0x9E, 0x72, 0xF2, 0x35, 0xBC, 0xFC, 0x1E, 0x81, 0x08
};

/*****************************************table10*********************************************/
u8 key10[]={
0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5
};
u8 iv10[]={
0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5D, 0x39
};
u8 aad10[]={
0x88, 0x41, 0x00, 0x14, 0x72, 0x03, 0x0C, 0x77, 0x44, 0x94, 0xFC, 0xF3, 0x1E, 0x64, 0x00, 0x00,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
0x00, 0x34
};
u8 pdata10[]={
0xAF, 0x26, 0xDA, 0xA5, 0x41, 0xD2, 0x60, 0xF7, 0x39, 0x73, 0x02, 0xE1, 0xF1, 0x20, 0x72, 0x9E,
0x85, 0x67, 0x02, 0xC0, 0xD8, 0x98, 0x8F, 0x8D, 0x3E, 0x09, 0x42, 0x3F, 0x61, 0x26, 0x3A, 0xEB,
0x80, 0x0B, 0xD6, 0x87, 0xBA, 0xCD, 0x61, 0xC1, 0x4D, 0x07, 0x40, 0xB1, 0x3D, 0xFE, 0x38, 0x0B,
0x27, 0x5B, 0xD0, 0xA1
};
u8 cdata10[]={
0x83, 0xB6, 0x2B, 0xC2, 0x10, 0x3D, 0x6A, 0x02, 0xC4, 0x7B, 0x51, 0x38, 0x91, 0x20, 0x01, 0x2A,
0x35, 0x66, 0xB2, 0x28, 0x68, 0x44, 0xCE, 0x16, 0xD3, 0x65, 0xBA, 0x1F, 0xED, 0x0F, 0x55, 0xC5,
0x05, 0xDA, 0xB4, 0x78, 0x91, 0x6F, 0xDF, 0x2D, 0xE6, 0xFD, 0x29, 0x39, 0x44, 0x68, 0xBE, 0x72,
0x0B, 0x52, 0x2B, 0x09
};
u8 mictag10[]={
0xE7, 0xCC, 0x0E, 0x04, 0x25, 0x39, 0x7D, 0x01, 0x6E, 0x78, 0x6F, 0xAD, 0xE9, 0x11, 0x89, 0x60
};

/*****************************************table11*********************************************/
u8 key11[]={
0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5
};
u8 iv11[]={
0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5D, 0x40
};
u8 aad11[]={
0x08, 0x41, 0x00, 0x14, 0x72, 0x03, 0x0C, 0x77, 0x44, 0x94, 0xFC, 0xF3, 0x1E, 0x64, 0x00, 0x00,
0x00, 0x14, 0x72, 0x03, 0x0C, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56
};
u8 pdata11[]={
0x0B, 0x24, 0x54, 0x44, 0x5B, 0xA2, 0x37, 0xE8, 0x66, 0xB3, 0x13, 0x58, 0xFC, 0x42, 0x89, 0x5D,
0xC6, 0x5A, 0xC0, 0x04, 0xDD, 0x0F, 0xBE, 0x39, 0x02, 0xFC, 0x98, 0x63, 0x9B, 0x19, 0xE4, 0x7F,
0xFD, 0x04, 0xF6, 0x5C, 0x05, 0x84, 0x63, 0xEA, 0xAB, 0xD2, 0xE5, 0x4C, 0x93, 0xC4, 0x30, 0x01,
0xAD, 0xEB, 0x72, 0x1D, 0xFB, 0x07, 0x87, 0xD7, 0xB8, 0x4F, 0x6A, 0x15, 0x62, 0xAF, 0x74, 0x1A,
0xB8, 0x49, 0x8F, 0xB7, 0x37, 0xB9, 0x7B, 0xDD, 0x89, 0x1D, 0xE0, 0x05, 0x3D, 0x9A, 0x5C, 0x32,
0xE2, 0xB1, 0x7C, 0xD8, 0x60, 0x78
};
u8 cdata11[]={
0x93, 0x00, 0xCA, 0x6E, 0xC9, 0x41, 0xA4, 0xAF, 0x6E, 0x07, 0x48, 0x87, 0x0A, 0x47, 0x39, 0x28,
0xF0, 0x8B, 0xE4, 0xB0, 0x3D, 0x1C, 0xF8, 0x9E, 0x26, 0x35, 0x3D, 0x94, 0xA4, 0x8E, 0xC3, 0xAF,
0xB9, 0x17, 0xC0, 0xCA, 0x64, 0x0F, 0x99, 0x53, 0x3A, 0xDC, 0x12, 0xE5, 0x7E, 0xB4, 0xDE, 0x3A,
0x1B, 0xB5, 0x9E, 0x3F, 0x51, 0xA7, 0x10, 0x19, 0xD2, 0x04, 0x0E, 0xE5, 0x56, 0x30, 0x8A, 0xCF,
0xA2, 0xE0, 0x60, 0x49, 0xA6, 0xAE, 0xBF, 0xA7, 0x70, 0x1D, 0x2A, 0x4C, 0xC4, 0x48, 0xF7, 0x25,
0x7F, 0xCE, 0x63, 0x33, 0xA3, 0x90
};
u8 mictag11[]={
0xA1, 0x76, 0x5A, 0x4D, 0x01, 0xFB, 0x14, 0xB2, 0x71, 0xF5, 0xFC, 0xAE, 0xC1, 0x52, 0xF9, 0x2D
};

/*****************************************table12*********************************************/
u8 key12[]={
0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5
};
u8 iv12[]={
0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5D, 0x41
};
u8 aad12[]={
0x08, 0x41, 0x00, 0x14, 0x72, 0x03, 0x0C, 0x77, 0x44, 0x94, 0xFC, 0xF3, 0x1E, 0x64, 0x00, 0x00,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34
};
u8 pdata12[]={
0x00, 0x3C, 0x4F, 0x4B, 0x00, 0x00, 0x3F, 0x01, 0xB2, 0xA4, 0xC0, 0xA8, 0x01, 0x01, 0xAC, 0x10,
0x0C, 0x18, 0x00, 0x00, 0x55, 0x56, 0x00, 0x01, 0x00, 0x05, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
0x77, 0x61, 0x62, 0x63
};
u8 cdata12[]={
0x4E, 0x91, 0xC1, 0xE9, 0x94, 0x27, 0xDF, 0xDC, 0x04, 0x21, 0xE4, 0xE5, 0x88, 0x7B, 0xB2, 0x18,
0xE1, 0xA3, 0x38, 0x18, 0xE4, 0x27, 0x20, 0x5A, 0xD1, 0x4D, 0x8B, 0xD4, 0x42, 0x7C, 0xCC, 0x86,
0x12, 0x0B, 0xFB, 0x9A, 0xF1, 0x84, 0xE8, 0x00, 0x25, 0xB9, 0x1E, 0xEF, 0x62, 0x1D, 0xD7, 0x3C,
0x1E, 0xD0, 0x1A, 0x31
};
u8 mictag12[]={
0x9B, 0xC3, 0x33, 0xB5, 0x44, 0x19, 0x57, 0x39, 0x75, 0xBF, 0xCF, 0x56, 0x9E, 0x35, 0xD7, 0xD3
};
/*****************************************table13*********************************************/
u8 key13[]={
0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5
};
u8 iv13[]={
0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5D, 0x84	
};
u8 aad13[]={
0x80, 0x40, 0x00, 0x14, 0x72, 0x03, 0x0C, 0x77, 0x44, 0x94, 0xFC, 0xF3, 0x1E, 0x64, 0x00, 0x00,
0x00, 0x14, 0x72, 0x03, 0x0C, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02
};
u8 pdata13[]={
0x02, 0x00
};
u8 cdata13[]={
0x5D, 0xB9
};
u8 mictag13[]={
0x6A, 0xAA, 0x61, 0x3B, 0x47, 0x5E, 0xEA, 0xEE, 0xE4, 0x45, 0x50, 0x99, 0x09, 0x0F, 0xC9, 0xFF
};

/*****************************************table14*********************************************/
u8 key14[]={
0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5, 0x5A, 0xA5
};
u8 iv14[]={
0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5D, 0x8A
};
u8 aad14[]={
0xC0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x44, 0x94, 0xFC, 0xF3, 0x1E, 0x64, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0xDD, 0x28, 0x00, 0x14, 0x72, 0x00, 0x02, 0x22, 0x00, 0x01,
0x8A, 0x5D, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C, 0x36, 0x5C,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
u8 pdata14[]={
};
u8 cdata14[]={
};
u8 mictag14[]={
0xC0, 0xA5, 0x77, 0xB0, 0x4F, 0x25, 0xC9, 0xAC, 0xAB, 0x81, 0x45, 0x50, 0x7E, 0xC3, 0x46, 0x7A
};


u8 *KEY[]={
key0,key1,key2,key3,key4,key5,key6,key7,key8,key9,key10,key11,key12,key13,key14
};
u8 *IV[]={
iv0,iv1,iv2,iv3,iv4,iv5,iv6,iv7,iv8,iv9,iv10,iv11,iv12,iv13,iv14
};
u8 *AAD[]={
aad0,aad1,aad2,aad3,aad4,aad5,aad6,aad7,aad8,aad9,aad10,aad11,aad12,aad13,aad14
};
u8 *PDATA[]={
pdata0,pdata1,pdata2,pdata3,pdata4,pdata5,pdata6,pdata7,pdata8,pdata9,pdata10,pdata11,pdata12,pdata13,pdata14
};
u8 *CDATA[]={
cdata0,cdata1,cdata2,cdata3,cdata4,cdata5,cdata6,cdata7,cdata8,cdata9,cdata10,cdata11,cdata12,cdata13,cdata14
};
u8 *MICTAG[]={
mictag0,mictag1,mictag2,mictag3,mictag4,mictag5,mictag6,mictag7,mictag8,mictag9,mictag10,mictag11,mictag12,mictag13,mictag14
};

#endif

static void dump_buf(u8 *buf, u32 len)
{
	u32 i;
	for (i = 0; i < len; i++){
		printk("%2.2X, ", *(buf + i));
		if(((i+1)%16) ==0)
			printk("\n");
	}
	printk("\n");
}
#define DUMP_DATA(x, buf, len) \
		do { if (1) { \
			printk("%s:\n", x);\
			dump_buf((buf), (len)); } \
		} while (0);
/***************gcm128_start************************/
#define CRYPTO_memcmp memcmp
#define TABLE_BITS 4
#if (defined(_WIN32) || defined(_WIN64)) && !defined(__MINGW32__)
typedef __int64 i64;
typedef unsigned __int64 u64;
# define U64(C) C##UI64
#elif defined(__arch64__)
typedef long i64;
typedef unsigned long u64;
# define U64(C) C##UL
#else
typedef long long i64;
//typedef unsigned long long u64;
# define U64(C) C##ULL
#endif

#if defined(BSWAP4) && !defined(STRICT_ALIGNMENT)
# define GETU32(p)       BSWAP4(*(const u32_a1 *)(p))
# define PUTU32(p,v)     *(u32_a1 *)(p) = BSWAP4(v)
#else
# define GETU32(p)       ((u32)(p)[0]<<24|(u32)(p)[1]<<16|(u32)(p)[2]<<8|(u32)(p)[3])
# define PUTU32(p,v)     ((p)[0]=(u8)((v)>>24),(p)[1]=(u8)((v)>>16),(p)[2]=(u8)((v)>>8),(p)[3]=(u8)(v))
#endif
/*- GCM definitions */ typedef struct {
    u64 hi, lo;
} u128;



#define PACK(s)		((size_t)(s)<<(sizeof(size_t)*8-16))
#define REDUCE1BIT(V)   do { \
		if (sizeof(size_t)==8) { \
			u64 T = U64(0xe100000000000000) & (0-(V.lo&1)); \
			V.lo  = (V.hi<<63)|(V.lo>>1); \
			V.hi  = (V.hi>>1 )^T; \
		} \
		else { \
			u32 T = 0xe1000000U & (0-(u32)(V.lo&1)); \
			V.lo  = (V.hi<<63)|(V.lo>>1); \
			V.hi  = (V.hi>>1 )^((u64)T<<32); \
		} \
} while(0)


typedef void (*block128_f) (const unsigned char in[16],
							unsigned char out[16], const void *key);


struct gcm128_context {
	/* Following 6 names follow names in GCM specification */
	union {
		u64 u[2];
		u32 d[4];
		u8 c[16];
		size_t t[16 / sizeof(size_t)];
	} Yi, EKi, EK0, len, Xi, H;
    /*
 *      * Relative position of Xi, H and pre-computed Htable is used in some
 *           * assembler modules, i.e. don't change the order!
 *                */
#if TABLE_BITS==8
	u128 Htable[256];
#else
	u128 Htable[16];
	void (*gmult) (u64 Xi[2], const u128 Htable[16]);
	void (*ghash) (u64 Xi[2], const u128 Htable[16], const u8 *inp,
					size_t len);
#endif
	unsigned int mres, ares;
	block128_f block;
	void *key;
#if !defined(OPENSSL_SMALL_FOOTPRINT)
	unsigned char Xn[48];
#endif
};

typedef struct gcm128_context GCM128_CONTEXT;

# define GCM_MUL(ctx)			gcm_gmult_4bit(ctx->Xi.u,ctx->Htable)

static void gcm_init_4bit(u128 Htable[16], u64 H[2])
{
	u128 V;
# if defined(OPENSSL_SMALL_FOOTPRINT)
	int i;
# endif

	Htable[0].hi = 0;
	Htable[0].lo = 0;
	V.hi = H[0];
	V.lo = H[1];

# if defined(OPENSSL_SMALL_FOOTPRINT)
	for (Htable[8] = V, i = 4; i > 0; i >>= 1) {
		REDUCE1BIT(V);
		Htable[i] = V;
	}

	for (i = 2; i < 16; i <<= 1) {
		u128 *Hi = Htable + i;
		int j;
		for (V = *Hi, j = 1; j < i; ++j) {
			Hi[j].hi = V.hi ^ Htable[j].hi;
			Hi[j].lo = V.lo ^ Htable[j].lo;
		}
	}
# else
	Htable[8] = V;
	REDUCE1BIT(V);
	Htable[4] = V;
	REDUCE1BIT(V);
	Htable[2] = V;
	REDUCE1BIT(V);
	Htable[1] = V;
	Htable[3].hi = V.hi ^ Htable[2].hi, Htable[3].lo = V.lo ^ Htable[2].lo;
	V = Htable[4];
	Htable[5].hi = V.hi ^ Htable[1].hi, Htable[5].lo = V.lo ^ Htable[1].lo;
	Htable[6].hi = V.hi ^ Htable[2].hi, Htable[6].lo = V.lo ^ Htable[2].lo;
	Htable[7].hi = V.hi ^ Htable[3].hi, Htable[7].lo = V.lo ^ Htable[3].lo;
	V = Htable[8];
	Htable[9].hi = V.hi ^ Htable[1].hi, Htable[9].lo = V.lo ^ Htable[1].lo;
	Htable[10].hi = V.hi ^ Htable[2].hi, Htable[10].lo = V.lo ^ Htable[2].lo;
	Htable[11].hi = V.hi ^ Htable[3].hi, Htable[11].lo = V.lo ^ Htable[3].lo;
	Htable[12].hi = V.hi ^ Htable[4].hi, Htable[12].lo = V.lo ^ Htable[4].lo;
	Htable[13].hi = V.hi ^ Htable[5].hi, Htable[13].lo = V.lo ^ Htable[5].lo;
	Htable[14].hi = V.hi ^ Htable[6].hi, Htable[14].lo = V.lo ^ Htable[6].lo;
	Htable[15].hi = V.hi ^ Htable[7].hi, Htable[15].lo = V.lo ^ Htable[7].lo;
# endif
# if defined(GHASH_ASM) && (defined(__arm__) || defined(__arm))
    /*
 *      * ARM assembler expects specific dword order in Htable.
 *           */
	{
		int j;
		const union {
			long one;
			char little;
		} is_endian = { 1 };

		if (is_endian.little)
			for (j = 0; j < 16; ++j) {
				V = Htable[j];
				Htable[j].hi = V.lo;
				Htable[j].lo = V.hi;
		} else
			for (j = 0; j < 16; ++j) {
				V = Htable[j];
				Htable[j].hi = V.lo << 32 | V.lo >> 32;
				Htable[j].lo = V.hi << 32 | V.hi >> 32;
			}
	}
# endif
}


void CRYPTO_gcm128_init(GCM128_CONTEXT *ctx, void *key, block128_f block)
{
	const union {
		long one;
		char little;
	} is_endian = { 1 };
	memset(ctx, 0, sizeof(*ctx));
	ctx->block = block;
	ctx->key = key;

	(*block) (ctx->H.c, ctx->H.c, key);

	if (is_endian.little) {
		/* H is stored in host byte order */
#ifdef BSWAP8
		ctx->H.u[0] = BSWAP8(ctx->H.u[0]);
		ctx->H.u[1] = BSWAP8(ctx->H.u[1]);
#else
		u8 *p = ctx->H.c;
		u64 hi, lo;
		hi = (u64)GETU32(p) << 32 | GETU32(p + 4);
		lo = (u64)GETU32(p + 8) << 32 | GETU32(p + 12);
		ctx->H.u[0] = hi;
		ctx->H.u[1] = lo;
#endif
	}
#if	TABLE_BITS==8
	gcm_init_8bit(ctx->Htable, ctx->H.u);
#elif	TABLE_BITS==4
	gcm_init_4bit(ctx->Htable, ctx->H.u);
#endif
}

static const size_t rem_4bit[16] = {
	PACK(0x0000), PACK(0x1C20), PACK(0x3840), PACK(0x2460),
	PACK(0x7080), PACK(0x6CA0), PACK(0x48C0), PACK(0x54E0),
	PACK(0xE100), PACK(0xFD20), PACK(0xD940), PACK(0xC560),
	PACK(0x9180), PACK(0x8DA0), PACK(0xA9C0), PACK(0xB5E0)
};

static void gcm_gmult_4bit(u64 Xi[2], const u128 Htable[16])
{
	u128 Z;
	int cnt = 15;
	size_t rem, nlo, nhi;
	const union {
		long one;
		char little;
	} is_endian = { 1 };

	nlo = ((const u8 *)Xi)[15];
	nhi = nlo >> 4;
	nlo &= 0xf;

	Z.hi = Htable[nlo].hi;
	Z.lo = Htable[nlo].lo;

	while (1) {
		rem = (size_t)Z.lo & 0xf;
		Z.lo = (Z.hi << 60) | (Z.lo >> 4);
		Z.hi = (Z.hi >> 4);
		if (sizeof(size_t) == 8)
		    Z.hi ^= rem_4bit[rem];
		else
		    Z.hi ^= (u64)rem_4bit[rem] << 32;

		Z.hi ^= Htable[nhi].hi;
		Z.lo ^= Htable[nhi].lo;

		if (--cnt < 0)
		    break;

		nlo = ((const u8 *)Xi)[cnt];
		nhi = nlo >> 4;
		nlo &= 0xf;

		rem = (size_t)Z.lo & 0xf;
		Z.lo = (Z.hi << 60) | (Z.lo >> 4);
		Z.hi = (Z.hi >> 4);
		if (sizeof(size_t) == 8)
		    Z.hi ^= rem_4bit[rem];
		else
		    Z.hi ^= (u64)rem_4bit[rem] << 32;

		Z.hi ^= Htable[nlo].hi;
		Z.lo ^= Htable[nlo].lo;
	}

	if (is_endian.little) {
#  ifdef BSWAP8
		Xi[0] = BSWAP8(Z.hi);
		Xi[1] = BSWAP8(Z.lo);
#  else
		u8 *p = (u8 *)Xi;
		u32 v;
		v = (u32)(Z.hi >> 32);
		PUTU32(p, v);
		v = (u32)(Z.hi);
		PUTU32(p + 4, v);
		v = (u32)(Z.lo >> 32);
		PUTU32(p + 8, v);
		v = (u32)(Z.lo);
		PUTU32(p + 12, v);
#  endif
	} else {
		Xi[0] = Z.hi;
		Xi[1] = Z.lo;
	}
}



void CRYPTO_gcm128_setiv(GCM128_CONTEXT *ctx, const unsigned char *iv,
								size_t len)
{
	const union {
		long one;
		char little;
	} is_endian = { 1 };
	unsigned int ctr;
#ifdef GCM_FUNCREF_4BIT
	void (*gcm_gmult_p) (u64 Xi[2], const u128 Htable[16]) = ctx->gmult;
#endif

	ctx->len.u[0] = 0;          /* AAD length */
	ctx->len.u[1] = 0;          /* message length */
	ctx->ares = 0;
	ctx->mres = 0;

	if (len == 12) {
		memcpy(ctx->Yi.c, iv, 12);
		ctx->Yi.c[12] = 0;
		ctx->Yi.c[13] = 0;
		ctx->Yi.c[14] = 0;
		ctx->Yi.c[15] = 1;
		ctr = 1;
	} else {
		size_t i;
		u64 len0 = len;

		/* Borrow ctx->Xi to calculate initial Yi */
		ctx->Xi.u[0] = 0;
		ctx->Xi.u[1] = 0;

		while (len >= 16) {
			for (i = 0; i < 16; ++i)
			    ctx->Xi.c[i] ^= iv[i];
			GCM_MUL(ctx);
			iv += 16;
			len -= 16;
		}
		if (len) {
			for (i = 0; i < len; ++i)
				ctx->Xi.c[i] ^= iv[i];
			GCM_MUL(ctx);
		}
		len0 <<= 3;
		if (is_endian.little) {
#ifdef BSWAP8
			ctx->Xi.u[1] ^= BSWAP8(len0);
#else
			ctx->Xi.c[8] ^= (u8)(len0 >> 56);
			ctx->Xi.c[9] ^= (u8)(len0 >> 48);
			ctx->Xi.c[10] ^= (u8)(len0 >> 40);
			ctx->Xi.c[11] ^= (u8)(len0 >> 32);
			ctx->Xi.c[12] ^= (u8)(len0 >> 24);
			ctx->Xi.c[13] ^= (u8)(len0 >> 16);
			ctx->Xi.c[14] ^= (u8)(len0 >> 8);
			ctx->Xi.c[15] ^= (u8)(len0);
#endif
		} else {
			ctx->Xi.u[1] ^= len0;
		}

		GCM_MUL(ctx);

		if (is_endian.little)
#ifdef BSWAP4
			ctr = BSWAP4(ctx->Xi.d[3]);
#else
			ctr = GETU32(ctx->Xi.c + 12);
#endif
		else
			ctr = ctx->Xi.d[3];

		/* Copy borrowed Xi to Yi */
		ctx->Yi.u[0] = ctx->Xi.u[0];
		ctx->Yi.u[1] = ctx->Xi.u[1];
	}

	


	ctx->Xi.u[0] = 0;
	ctx->Xi.u[1] = 0;

	(*ctx->block) (ctx->Yi.c, ctx->EK0.c, ctx->key);
	++ctr;
	if (is_endian.little)
#ifdef BSWAP4
		ctx->Yi.d[3] = BSWAP4(ctr);
#else
		PUTU32(ctx->Yi.c + 12, ctr);
#endif
	else
		ctx->Yi.d[3] = ctr;
}

int CRYPTO_gcm128_aad(GCM128_CONTEXT *ctx, const unsigned char *aad,
					size_t len)
{
	size_t i;
	unsigned int n;
	u64 alen = ctx->len.u[0];
#ifdef GCM_FUNCREF_4BIT
	void (*gcm_gmult_p) (u64 Xi[2], const u128 Htable[16]) = ctx->gmult;
# ifdef GHASH
	void (*gcm_ghash_p) (u64 Xi[2], const u128 Htable[16],
						const u8 *inp, size_t len) = ctx->ghash;
# endif
#endif

	if (ctx->len.u[1])
		return -2;

	alen += len;
	if (alen > (U64(1) << 61) || (sizeof(len) == 8 && alen < len))
		return -1;
	ctx->len.u[0] = alen;

	n = ctx->ares;

	if (n) {
		while (n && len) {
			ctx->Xi.c[n] ^= *(aad++);
			--len;
			n = (n + 1) % 16;
		}
		if (n == 0)
			GCM_MUL(ctx);
		else {
			ctx->ares = n;
			return 0;
		}
	}
#ifdef GHASH
	if ((i = (len & (size_t)-16))) {
		GHASH(ctx, aad, i);
		aad += i;
		len -= i;
	}
#else
	while (len >= 16) {
		for (i = 0; i < 16; ++i)
			ctx->Xi.c[i] ^= aad[i];
		GCM_MUL(ctx);
		aad += 16;
		len -= 16;
	}
#endif
	if (len) {
		n = (unsigned int)len;
		for (i = 0; i < len; ++i)
			ctx->Xi.c[i] ^= aad[i];
	}

	ctx->ares = n;
	return 0;
}

int CRYPTO_gcm128_encrypt(GCM128_CONTEXT *ctx,
							const unsigned char *in, unsigned char *out,
							size_t len)
{
	const union {
		long one;
		char little;
	} is_endian = { 1 };
	unsigned int n, ctr, mres;
	size_t i;
	u64 mlen = ctx->len.u[1];
	block128_f block = ctx->block;
	void *key = ctx->key;
#ifdef GCM_FUNCREF_4BIT
	void (*gcm_gmult_p) (u64 Xi[2], const u128 Htable[16]) = ctx->gmult;
# if defined(GHASH) && !defined(OPENSSL_SMALL_FOOTPRINT)
	void (*gcm_ghash_p) (u64 Xi[2], const u128 Htable[16],
							const u8 *inp, size_t len) = ctx->ghash;
# endif
#endif

	mlen += len;
	if (mlen > ((U64(1) << 36) - 32) || (sizeof(len) == 8 && mlen < len))
		return -1;
	ctx->len.u[1] = mlen;

	mres = ctx->mres;

	if (ctx->ares) {
		/* First call to encrypt finalizes GHASH(AAD) */
#if defined(GHASH) && !defined(OPENSSL_SMALL_FOOTPRINT)
		if (len == 0) {
			GCM_MUL(ctx);
			ctx->ares = 0;
			return 0;
		}
		memcpy(ctx->Xn, ctx->Xi.c, sizeof(ctx->Xi));
		ctx->Xi.u[0] = 0;
		ctx->Xi.u[1] = 0;
		mres = sizeof(ctx->Xi);
#else
		GCM_MUL(ctx);
#endif
		ctx->ares = 0;
	}

	if (is_endian.little)
#ifdef BSWAP4
		ctr = BSWAP4(ctx->Yi.d[3]);
#else
		ctr = GETU32(ctx->Yi.c + 12);
#endif
	else
		ctr = ctx->Yi.d[3];



    n = mres % 16;
#if !defined(OPENSSL_SMALL_FOOTPRINT)
	if (16 % sizeof(size_t) == 0) { /* always true actually */
		do {
			if (n) {
# if defined(GHASH)
				while (n && len) {
					ctx->Xn[mres++] = *(out++) = *(in++) ^ ctx->EKi.c[n];
					--len;
					n = (n + 1) % 16;
				}
				if (n == 0) {
					GHASH(ctx, ctx->Xn, mres);
					mres = 0;
				} else {
					ctx->mres = mres;
					return 0;
				}
# else
				while (n && len) {
					ctx->Xi.c[n] ^= *(out++) = *(in++) ^ ctx->EKi.c[n];
					--len;
					n = (n + 1) % 16;
				}
				if (n == 0) {
					GCM_MUL(ctx);
					mres = 0;
				} else {
					ctx->mres = n;
					return 0;
				}
# endif
			}
# if defined(STRICT_ALIGNMENT)
			if (((size_t)in | (size_t)out) % sizeof(size_t) != 0)
				break;
# endif
# if defined(GHASH)
			if (len >= 16 && mres) {
				GHASH(ctx, ctx->Xn, mres);
				mres = 0;
			}
#  if defined(GHASH_CHUNK)
			while (len >= GHASH_CHUNK) {
				size_t j = GHASH_CHUNK;

				while (j) {
					size_t_aX *out_t = (size_t_aX *)out;
					const size_t_aX *in_t = (const size_t_aX *)in;

					(*block) (ctx->Yi.c, ctx->EKi.c, key);
					++ctr;
					if (is_endian.little)
#   ifdef BSWAP4
						ctx->Yi.d[3] = BSWAP4(ctr);
#   else
						PUTU32(ctx->Yi.c + 12, ctr);
#   endif
					else
						ctx->Yi.d[3] = ctr;
					for (i = 0; i < 16 / sizeof(size_t); ++i)
						out_t[i] = in_t[i] ^ ctx->EKi.t[i];
					out += 16;
					in += 16;
					j -= 16;
				}
				GHASH(ctx, out - GHASH_CHUNK, GHASH_CHUNK);
				len -= GHASH_CHUNK;
			}
#  endif
			if ((i = (len & (size_t)-16))) {
				size_t j = i;

				while (len >= 16) {
					size_t_aX *out_t = (size_t_aX *)out;
					const size_t_aX *in_t = (const size_t_aX *)in;

					(*block) (ctx->Yi.c, ctx->EKi.c, key);
					++ctr;
					if (is_endian.little)
#  ifdef BSWAP4
						ctx->Yi.d[3] = BSWAP4(ctr);
#  else
						PUTU32(ctx->Yi.c + 12, ctr);
#  endif
					else
						ctx->Yi.d[3] = ctr;
					for (i = 0; i < 16 / sizeof(size_t); ++i)
						out_t[i] = in_t[i] ^ ctx->EKi.t[i];
					out += 16;
					in += 16;
					len -= 16;
				}
				GHASH(ctx, out - j, j);
			}
# else
			while (len >= 16) {
				size_t *out_t = (size_t *)out;
				const size_t *in_t = (const size_t *)in;

				(*block) (ctx->Yi.c, ctx->EKi.c, key);
				++ctr;
				if (is_endian.little)
#  ifdef BSWAP4
					ctx->Yi.d[3] = BSWAP4(ctr);
#  else
					PUTU32(ctx->Yi.c + 12, ctr);
#  endif
					else
						ctx->Yi.d[3] = ctr;
					for (i = 0; i < 16 / sizeof(size_t); ++i)
						ctx->Xi.t[i] ^= out_t[i] = in_t[i] ^ ctx->EKi.t[i];
					GCM_MUL(ctx);
					out += 16;
					in += 16;
					len -= 16;
			}
# endif
			if (len) {
				(*block) (ctx->Yi.c, ctx->EKi.c, key);
				++ctr;
				if (is_endian.little)
# ifdef BSWAP4
					ctx->Yi.d[3] = BSWAP4(ctr);
# else
					PUTU32(ctx->Yi.c + 12, ctr);
# endif
				else
					ctx->Yi.d[3] = ctr;
# if defined(GHASH)
				while (len--) {
					ctx->Xn[mres++] = out[n] = in[n] ^ ctx->EKi.c[n];
					++n;
				}
# else
				while (len--) {
					ctx->Xi.c[n] ^= out[n] = in[n] ^ ctx->EKi.c[n];
					++n;
				}
				mres = n;
# endif
			}

			ctx->mres = mres;
			return 0;
		} while (0);
	}
#endif

	for (i = 0; i < len; ++i) {
		if (n == 0) {
			(*block) (ctx->Yi.c, ctx->EKi.c, key);
			++ctr;
			if (is_endian.little)
#ifdef BSWAP4
				ctx->Yi.d[3] = BSWAP4(ctr);
#else
				PUTU32(ctx->Yi.c + 12, ctr);
#endif
			else
				ctx->Yi.d[3] = ctr;
		}
		
#if defined(GHASH) && !defined(OPENSSL_SMALL_FOOTPRINT)
		ctx->Xn[mres++] = out[i] = in[i] ^ ctx->EKi.c[n];
		n = (n + 1) % 16;
		if (mres == sizeof(ctx->Xn)) {
			GHASH(ctx,ctx->Xn,sizeof(ctx->Xn));
			mres = 0;
		}
#else
		ctx->Xi.c[n] ^= out[i] = in[i] ^ ctx->EKi.c[n];
		mres = n = (n + 1) % 16;
		if (n == 0)
			GCM_MUL(ctx);
#endif
	}

	ctx->mres = mres;

	return 0;
}

int CRYPTO_gcm128_decrypt(GCM128_CONTEXT *ctx,
                          const unsigned char *in, unsigned char *out,
                          size_t len)
{
	const union {
		long one;
		char little;
	} is_endian = { 1 };
	unsigned int n, ctr, mres;
	size_t i;
	u64 mlen = ctx->len.u[1];
	block128_f block = ctx->block;
	void *key = ctx->key;
#ifdef GCM_FUNCREF_4BIT
	void (*gcm_gmult_p) (u64 Xi[2], const u128 Htable[16]) = ctx->gmult;
# if defined(GHASH) && !defined(OPENSSL_SMALL_FOOTPRINT)
	void (*gcm_ghash_p) (u64 Xi[2], const u128 Htable[16],
						const u8 *inp, size_t len) = ctx->ghash;
# endif
#endif

	mlen += len;
	if (mlen > ((U64(1) << 36) - 32) || (sizeof(len) == 8 && mlen < len))
		return -1;
	ctx->len.u[1] = mlen;

	mres = ctx->mres;

	if (ctx->ares) {
		/* First call to decrypt finalizes GHASH(AAD) */
#if defined(GHASH) && !defined(OPENSSL_SMALL_FOOTPRINT)
		if (len == 0) {
			GCM_MUL(ctx);
			ctx->ares = 0;
			return 0;
		}
		memcpy(ctx->Xn, ctx->Xi.c, sizeof(ctx->Xi));
		ctx->Xi.u[0] = 0;
		ctx->Xi.u[1] = 0;
		mres = sizeof(ctx->Xi);
#else
		GCM_MUL(ctx);
#endif
		ctx->ares = 0;
	}

	if (is_endian.little)
#ifdef BSWAP4
		ctr = BSWAP4(ctx->Yi.d[3]);
#else
		ctr = GETU32(ctx->Yi.c + 12);
#endif
	else
		ctr = ctx->Yi.d[3];

	n = mres % 16;
#if !defined(OPENSSL_SMALL_FOOTPRINT)
	if (16 % sizeof(size_t) == 0) { /* always true actually */
		do {
			if (n) {
# if defined(GHASH)
				while (n && len) {
					*(out++) = (ctx->Xn[mres++] = *(in++)) ^ ctx->EKi.c[n];
					--len;
					n = (n + 1) % 16;
				}
				if (n == 0) {
					GHASH(ctx, ctx->Xn, mres);
					mres = 0;
				} else {
					ctx->mres = mres;
					return 0;
				}
# else
				while (n && len) {
					u8 c = *(in++);
					*(out++) = c ^ ctx->EKi.c[n];
					ctx->Xi.c[n] ^= c;
					--len;
					n = (n + 1) % 16;
				}
				if (n == 0) {
					GCM_MUL(ctx);
					mres = 0;
				} else {
					ctx->mres = n;
					return 0;
				}
# endif
			}
# if defined(STRICT_ALIGNMENT)
			if (((size_t)in | (size_t)out) % sizeof(size_t) != 0)
				break;
# endif
# if defined(GHASH)
			if (len >= 16 && mres) {
				GHASH(ctx, ctx->Xn, mres);
				mres = 0;
			}
#  if defined(GHASH_CHUNK)
			while (len >= GHASH_CHUNK) {
				size_t j = GHASH_CHUNK;

				GHASH(ctx, in, GHASH_CHUNK);
				while (j) {
					size_t_aX *out_t = (size_t_aX *)out;
					const size_t_aX *in_t = (const size_t_aX *)in;

					(*block) (ctx->Yi.c, ctx->EKi.c, key);
					++ctr;
					if (is_endian.little)
#   ifdef BSWAP4
						ctx->Yi.d[3] = BSWAP4(ctr);
#   else
						PUTU32(ctx->Yi.c + 12, ctr);
#   endif
					else
						ctx->Yi.d[3] = ctr;
					for (i = 0; i < 16 / sizeof(size_t); ++i)
						out_t[i] = in_t[i] ^ ctx->EKi.t[i];
					out += 16;
					in += 16;
					j -= 16;
				}
				len -= GHASH_CHUNK;
			}
#  endif
			if ((i = (len & (size_t)-16))) {
				GHASH(ctx, in, i);
				while (len >= 16) {
					size_t_aX *out_t = (size_t_aX *)out;
					const size_t_aX *in_t = (const size_t_aX *)in;

					(*block) (ctx->Yi.c, ctx->EKi.c, key);
					++ctr;
					if (is_endian.little)
#  ifdef BSWAP4
						ctx->Yi.d[3] = BSWAP4(ctr);
#  else
						PUTU32(ctx->Yi.c + 12, ctr);
#  endif
					else
						ctx->Yi.d[3] = ctr;
					for (i = 0; i < 16 / sizeof(size_t); ++i)
						out_t[i] = in_t[i] ^ ctx->EKi.t[i];
					out += 16;
					in += 16;
					len -= 16;
				}
			}
# else
			while (len >= 16) {
				size_t *out_t = (size_t *)out;
				const size_t *in_t = (const size_t *)in;

				(*block) (ctx->Yi.c, ctx->EKi.c, key);
				++ctr;
				if (is_endian.little)
#  ifdef BSWAP4
					ctx->Yi.d[3] = BSWAP4(ctr);
#  else
					PUTU32(ctx->Yi.c + 12, ctr);
#  endif
				else
					ctx->Yi.d[3] = ctr;

				for (i = 0; i < 16 / sizeof(size_t); ++i) {
					size_t c = in_t[i];
					out_t[i] = c ^ ctx->EKi.t[i];
					ctx->Xi.t[i] ^= c;
				}
				GCM_MUL(ctx);
				out += 16;
				in += 16;
				len -= 16;
			}
# endif
			if (len) {
				(*block) (ctx->Yi.c, ctx->EKi.c, key);
				++ctr;
				if (is_endian.little)
# ifdef BSWAP4
					ctx->Yi.d[3] = BSWAP4(ctr);
# else
					PUTU32(ctx->Yi.c + 12, ctr);
# endif
				else
					ctx->Yi.d[3] = ctr;

# if defined(GHASH)
				while (len--) {
					out[n] = (ctx->Xn[mres++] = in[n]) ^ ctx->EKi.c[n];
					++n;
				}
# else
				while (len--) {
					u8 c = in[n];
					ctx->Xi.c[n] ^= c;
					out[n] = c ^ ctx->EKi.c[n];
					++n;
				}
				mres = n;
# endif
			}

			ctx->mres = mres;
			return 0;
		} while (0);
	}
#endif


	for (i = 0; i < len; ++i) {
		u8 c;
		if (n == 0) {
			(*block) (ctx->Yi.c, ctx->EKi.c, key);
			++ctr;
			if (is_endian.little)
#ifdef BSWAP4
				ctx->Yi.d[3] = BSWAP4(ctr);
#else
				PUTU32(ctx->Yi.c + 12, ctr);
#endif
			else
				ctx->Yi.d[3] = ctr;
		}
#if defined(GHASH) && !defined(OPENSSL_SMALL_FOOTPRINT)
		out[i] = (ctx->Xn[mres++] = c = in[i]) ^ ctx->EKi.c[n];
		n = (n + 1) % 16;
		if (mres == sizeof(ctx->Xn)) {
			GHASH(ctx,ctx->Xn,sizeof(ctx->Xn));
			mres = 0;
		}
#else
		

		c = in[i];
		out[i] = c ^ ctx->EKi.c[n];
		ctx->Xi.c[n] ^= c;
		mres = n = (n + 1) % 16;
		if (n == 0)
			GCM_MUL(ctx);
#endif
	}

	ctx->mres = mres;

	return 0;
}

int CRYPTO_gcm128_finish(GCM128_CONTEXT *ctx, const unsigned char *tag,
							size_t len)
{
	const union {
		long one;
		char little;
	} is_endian = { 1 };
	u64 alen = ctx->len.u[0] << 3;
	u64 clen = ctx->len.u[1] << 3;
#ifdef GCM_FUNCREF_4BIT
	void (*gcm_gmult_p) (u64 Xi[2], const u128 Htable[16]) = ctx->gmult;
# if defined(GHASH) && !defined(OPENSSL_SMALL_FOOTPRINT)
	void (*gcm_ghash_p) (u64 Xi[2], const u128 Htable[16],
						const u8 *inp, size_t len) = ctx->ghash;
# endif
#endif

#if defined(GHASH) && !defined(OPENSSL_SMALL_FOOTPRINT)
	u128 bitlen;
	unsigned int mres = ctx->mres;

	if (mres) {
		unsigned blocks = (mres + 15) & -16;

		memset(ctx->Xn + mres, 0, blocks - mres);
		mres = blocks;
		if (mres == sizeof(ctx->Xn)) {
			GHASH(ctx, ctx->Xn, mres);
			mres = 0;
		}
	} else if (ctx->ares) {
		GCM_MUL(ctx);
	}
#else
	if (ctx->mres || ctx->ares)
		GCM_MUL(ctx);
#endif

	if (is_endian.little) {
#ifdef BSWAP8
		alen = BSWAP8(alen);
		clen = BSWAP8(clen);
#else
		u8 *p = ctx->len.c;

		ctx->len.u[0] = alen;
		ctx->len.u[1] = clen;

		alen = (u64)GETU32(p) << 32 | GETU32(p + 4);
		clen = (u64)GETU32(p + 8) << 32 | GETU32(p + 12);
#endif
	}

#if defined(GHASH) && !defined(OPENSSL_SMALL_FOOTPRINT)
	bitlen.hi = alen;
	bitlen.lo = clen;
	memcpy(ctx->Xn + mres, &bitlen, sizeof(bitlen));
	mres += sizeof(bitlen);
	GHASH(ctx, ctx->Xn, mres);
#else
	ctx->Xi.u[0] ^= alen;
	ctx->Xi.u[1] ^= clen;
	GCM_MUL(ctx);
#endif

	ctx->Xi.u[0] ^= ctx->EK0.u[0];
	ctx->Xi.u[1] ^= ctx->EK0.u[1];

	if (tag && len <= sizeof(ctx->Xi))
		return CRYPTO_memcmp(ctx->Xi.c, tag, len);
	else
		return -1;
}

void CRYPTO_gcm128_tag(GCM128_CONTEXT *ctx, unsigned char *tag, size_t len)
{
	CRYPTO_gcm128_finish(ctx, NULL, 0);
	memcpy(tag, ctx->Xi.c,len <= sizeof(ctx->Xi.c) ? len : sizeof(ctx->Xi.c));
}


/****************************gcm128_end**************************/
#define Rotl(_x, _y) (((_x) << (_y)) | ((_x) >> (32 - (_y))))

#define L1(_B) ((_B) ^ Rotl(_B, 2) ^ Rotl(_B, 10) ^ Rotl(_B, 18) ^ Rotl(_B, 24))
#define L2(_B) ((_B) ^ Rotl(_B, 13) ^ Rotl(_B, 23))


static const u8 Sbox[256] = {
			0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05,
			0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99,
			0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62,
			0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6,
			0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8,
			0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35,
			0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87,
			0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e,
			0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1,
			0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3,
			0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f,
			0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51,
			0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8,
			0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0,
			0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84,
			0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48
		};

static const u32 CK[32] = {
			0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,
			0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,
			0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,
			0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,
			0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,
			0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,
			0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,
			0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279 
		};


#define ByteSub(_A) (Sbox[(_A) >> 24] << 24 ^ \
                     Sbox[(_A) >> 16 & 0xFF] << 16 ^ \
                     Sbox[(_A) >>  8 & 0xFF] <<  8 ^ \
                     Sbox[(_A) & 0xFF])



static inline void xor_block(void *dst, void *src1, void *src2)
/* 128-bit xor: *dst = *src1 xor *src2. Pointers must be 32-bit aligned  */
{
    ((u32 *)dst)[0] = ((u32 *)src1)[0] ^ ((u32 *)src2)[0];
    ((u32 *)dst)[1] = ((u32 *)src1)[1] ^ ((u32 *)src2)[1];
    ((u32 *)dst)[2] = ((u32 *)src1)[2] ^ ((u32 *)src2)[2];
    ((u32 *)dst)[3] = ((u32 *)src1)[3] ^ ((u32 *)src2)[3];
}

static void SMS4Crypt(u8 *Input, u8 *Output, u32 *rk)
{
	u32 r, mid, x0, x1, x2, x3, *p;
	p = (u32 *)Input;
	x0 = p[0];
	x1 = p[1];
	x2 = p[2];
	x3 = p[3];	
#ifdef CONFIG_LITTLE_ENDIAN
	x0 = Rotl(x0, 16); x0 = ((x0 & 0x00FF00FF) << 8) ^ ((x0 & 0xFF00FF00) >> 8);
	x1 = Rotl(x1, 16); x1 = ((x1 & 0x00FF00FF) << 8) ^ ((x1 & 0xFF00FF00) >> 8);
	x2 = Rotl(x2, 16); x2 = ((x2 & 0x00FF00FF) << 8) ^ ((x2 & 0xFF00FF00) >> 8);
	x3 = Rotl(x3, 16); x3 = ((x3 & 0x00FF00FF) << 8) ^ ((x3 & 0xFF00FF00) >> 8);
#endif
	for (r = 0; r < 32; r += 4) {
		mid = x1 ^ x2 ^ x3 ^ rk[r + 0];
		mid = ByteSub(mid);
		x0 ^= L1(mid);
		mid = x2 ^ x3 ^ x0 ^ rk[r + 1];
		mid = ByteSub(mid);
		x1 ^= L1(mid);
		mid = x3 ^ x0 ^ x1 ^ rk[r + 2];
		mid = ByteSub(mid);
		x2 ^= L1(mid);
		mid = x0 ^ x1 ^ x2 ^ rk[r + 3];
		mid = ByteSub(mid);
		x3 ^= L1(mid);
	}
#ifdef CONFIG_LITTLE_ENDIAN
	x0 = Rotl(x0, 16); x0 = ((x0 & 0x00FF00FF) << 8) ^ ((x0 & 0xFF00FF00) >> 8);
	x1 = Rotl(x1, 16); x1 = ((x1 & 0x00FF00FF) << 8) ^ ((x1 & 0xFF00FF00) >> 8);
	x2 = Rotl(x2, 16); x2 = ((x2 & 0x00FF00FF) << 8) ^ ((x2 & 0xFF00FF00) >> 8);
	x3 = Rotl(x3, 16); x3 = ((x3 & 0x00FF00FF) << 8) ^ ((x3 & 0xFF00FF00) >> 8);
#endif
	p = (u32 *)Output;
	p[0] = x3;
	p[1] = x2;
	p[2] = x1;
	p[3] = x0;
}

static void SMS4KeyExt(u8 *Key, u32 *rk)
{
	u32 r, mid, x0, x1, x2, x3, *p;
	p = (u32 *)Key;
	x0 = p[0];
	x1 = p[1];
	x2 = p[2];
	x3 = p[3];
#ifdef CONFIG_LITTLE_ENDIAN
	x0 = Rotl(x0, 16); x0 = ((x0 & 0xFF00FF) << 8) ^ ((x0 & 0xFF00FF00) >> 8);
	x1 = Rotl(x1, 16); x1 = ((x1 & 0xFF00FF) << 8) ^ ((x1 & 0xFF00FF00) >> 8);
	x2 = Rotl(x2, 16); x2 = ((x2 & 0xFF00FF) << 8) ^ ((x2 & 0xFF00FF00) >> 8);
	x3 = Rotl(x3, 16); x3 = ((x3 & 0xFF00FF) << 8) ^ ((x3 & 0xFF00FF00) >> 8);
#endif

	x0 ^= 0xa3b1bac6;
	x1 ^= 0x56aa3350;
	x2 ^= 0x677d9197;
	x3 ^= 0xb27022dc;
	
	for (r = 0; r < 32; r += 4) {
		mid = x1 ^ x2 ^ x3 ^ CK[r + 0];
		mid = ByteSub(mid);
		rk[r + 0] = x0 ^= L2(mid);
		mid = x2 ^ x3 ^ x0 ^ CK[r + 1];
		mid = ByteSub(mid);
		rk[r + 1] = x1 ^= L2(mid);
		mid = x3 ^ x0 ^ x1 ^ CK[r + 2];
		mid = ByteSub(mid);
		rk[r + 2] = x2 ^= L2(mid);
		mid = x0 ^ x1 ^ x2 ^ CK[r + 3];
		mid = ByteSub(mid);
		rk[r + 3] = x3 ^= L2(mid);
	}
}

static void GCM_SM4Crypt(const unsigned char *Input, unsigned char *Output, const void *key)
{
	u32 rk[32];

	SMS4KeyExt((u8 *)key, rk);
	SMS4Crypt((u8 *)Input, (u8 *)Output, rk);
}

void rtw_wapi_sms4_cryption(u8 *Key, u8 *IV, u8 *Input, u16 InputLength,
			    u8 *Output, u16 *OutputLength)
{
	u32 blockNum, i, j;
	u16 remainder;
	u32 rk[32];
	u8 tmp[16];

	remainder = InputLength & 0x0F;
	blockNum = InputLength >> 4;

	for (i = 0; i < 16; i++)
		tmp[i] = IV[15 - i];

	SMS4KeyExt(Key, rk);

	for (i = 0; i < blockNum; i++) {
		SMS4Crypt(tmp, tmp, rk);
		xor_block(Output, Input, tmp);
		Output += 16;
		Input += 16;
	}

	if (remainder > 0) {
		*OutputLength = (i << 4) + remainder;
		SMS4Crypt(tmp, tmp, rk);

		for (j = 0; j < remainder; j++)
			Output[j] = Input[j] ^ tmp[j];
	}
	else
		*OutputLength = i << 4;
}

void rtw_wapi_construct_mic_part1(u8 keyIdx, u8 *pframe, u8 qos, u16 pdu_len, u8 *part1, u8 *part1_len)
{
	int a4_flag = 0;
	int offset = 0;

	*((u16 *)part1) = *((u16 *)pframe); //FrameCtrl	
#ifdef CONFIG_LITTLE_ENDIAN
	*((u16 *)part1) &= 0xc78f;  //set bit 4, 5, 6, 11, 12, 13 to 0
	*((u16 *)part1) |= 0x4000;	//set bit 14 to 1

	/* New spec requires if QoS existed, set AAD FC bit15 to 0. 
	   But existing device (such as: Redmi K40 Pro), not set AAD FC bit15 to 0 when existed QoS.
	   So if according to the new spec to set AAD FC bit15, it will happens Compatibility issues.

	   In order to keep compatibility, does not set AAD FC bit15 to 0 temporarily.
	*/ 
	
	//if (qos)
	//	*((u16 *)part1) &= 0x7fff;	//set bit 15 to 0
		
#else
	*((u16 *)part1) &= 0x8fc7;
	*((u16 *)part1) |= 0x0040;	//set bit 14 to 1

	/* New spec requires if QoS existed, set AAD FC bit15 to 0. 
	   But existing device (such as: Redmi K40 Pro), not set AAD FC bit15 to 0 when existed QoS.
	   So if according to the new spec to set AAD FC bit15, it will happens Compatibility issues.

	   In order to keep compatibility, does not set AAD FC bit15 to 0 temporarily.
	*/
	
	//if (qos)
	//	*((u16 *)part1) &= 0xff7f;	//set bit 15 to 0
#endif
	offset += 2;

	_rtw_memcpy(part1 + offset, pframe + 4, 12); //Addr1, Addr2
	offset += 12;
	
	_rtw_memcpy(part1 + offset, pframe + 22, 2); // SeqCtrl
	
#ifdef CONFIG_LITTLE_ENDIAN
	*((u16 *)(part1 + offset)) &= 0x000f;
#else
	*((u16 *)(part1 + offset)) &= 0x0f00;
#endif
	offset += 2;

	_rtw_memcpy(part1 + offset, pframe + 16, 6); // Addr3
	offset += 6;

	if (get_tofr_ds(pframe) == 3) {
		_rtw_memcpy(part1 + offset, pframe + 24, 6); // Addr4		
		a4_flag = 1;
	} else {
		_rtw_memset(part1 + offset, 0, 6);		
	}
	offset += 6;		
	

	if (qos) {
		if (a4_flag)
			_rtw_memcpy(part1 + offset, pframe + 30, 2); // QoS
		else 
			_rtw_memcpy(part1 + offset, pframe + 24, 2); // QoS

		/*
			New spec requires set AAD QoS bit 4~6 and 8~15 to 0.
			But existing device (such as: Redmi K40 Pro), set bit 5~6 and 8~15 to 0.
			
			In order to keep compatibility, just set AAD QoS bit 5~6 and 8~15 to 0.
		*/
#if 0		
#ifdef CONFIG_LITTLE_ENDIAN
		*((u16 *)(part1 + offset)) &= 0x008f; //set bit 4~6  8~15 to 0
#else
		*((u16 *)(part1 + offset)) &= 0x8f00;	//set bit 4~6  8~15 to 0
#endif

#else

#ifdef CONFIG_LITTLE_ENDIAN
		*((u16 *)(part1 + offset)) &= 0x009f; //set bit 5~6  8~15 to 0
#else
		*((u16 *)(part1 + offset)) &= 0x9f00;	//set bit 5~6  8~15 to 0
#endif
#endif
		offset += 2;
	}

	*(part1 + offset) = keyIdx;  //KeyIdx
	offset += 1;

	*(part1 + offset) = 0;  //Reserved
	offset += 1;

	*((u16 *)(part1 + offset)) = __constant_htons(pdu_len); //L
	offset += 2;

	*part1_len = offset;
}

#ifdef CONFIG_IEEE80211W
u8 _bip_sms4_protect(u8 *whdr_pos, size_t len, const u8 *key, size_t key_len,
		     const u8 *data, size_t data_len, u8 *mic)
{
	const u8 *iv = whdr_pos + len - WAPI_MIC_LEN - WAPI_PN_LEN;
	size_t count, left, i;
	u8 out[16], tmp[16];
	u32 rk[32];

	count = data_len >> 4;
	left = data_len & 0xf;

	for (i = 0; i < 16; i++)
		out[i] = iv[15 - i];

	SMS4KeyExt((u8 *)key, rk);
	SMS4Crypt(out, out, rk);

	for (i = 0; i < count; i++) {
		xor_block(out, (void *)data, out);
		SMS4Crypt(out, out, rk);
		data += 16;
	}

	if (left) {
		memset(tmp, 0, sizeof(tmp));
		memcpy(tmp, data, left);

		xor_block(out, tmp, out);
		SMS4Crypt(out, out, rk);
	}

	memcpy(mic, out, 16);
	return _SUCCESS;
}
#endif

void rtw_sms4_calculate_mic(u8 *Key, u8 *IV, u8 *Input1, u8 Input1Length,
			    u8 *Input2, u16 Input2Length, u8 *Output)
{
	u32 blockNum, i;
	u32 remainder;
	u32 rk[32];
	u8 out[16], tmp[16];

	remainder = Input1Length & 0x0F;
	blockNum = Input1Length >> 4;

	for (i = 0; i < 16; i++)
		out[i] = IV[15 - i];

	SMS4KeyExt(Key, rk);
	SMS4Crypt(out, out, rk);

	for (i = 0; i < blockNum; i++) {
		xor_block(out, Input1, out);
		SMS4Crypt(out, out, rk);
		Input1 += 16;
	}

	if (remainder != 0) {
		memset(tmp, 0, sizeof(tmp));
		memcpy(tmp, Input1, remainder);

		xor_block(out, tmp, out);
		SMS4Crypt(out, out, rk);
	}

	remainder = Input2Length & 0x0F;
	blockNum = Input2Length >> 4;

	for (i = 0; i < blockNum; i++) {
		xor_block(out, Input2, out);
		SMS4Crypt(out, out, rk);
		Input2 += 16;
	}

	if (remainder != 0) {
		memset(tmp, 0, sizeof(tmp));
		memcpy(tmp, Input2, remainder);

		xor_block(out, tmp, out);
		SMS4Crypt(out, out, rk);
	}

	memcpy(Output, out, 16);
}

u32	rtw_sms4_encrypt(_adapter *padapter, u8 *pxmitframe)
{
	u8 keyIdx;
	u8 *pDataKey = NULL;
	u8 *pMicKey = NULL;

	u16 curfragnum, payload_len;
	struct rtw_xmit_req *txreq = NULL;
	struct rtw_pkt_buf_list *pkt_list = NULL;
	u8 *pframe, *payload, *iv, *PN, *mic_result;

	u8 mic_part1[64];
	u8 part1_len = 0;
	u16 encrypt_len = 0;
	
	struct xmit_frame *xf = (struct xmit_frame *)pxmitframe;
	struct pkt_attrib *pattrib = &xf->attrib;
	WLAN_HDR_WAPI_EXT *pwapiExt = NULL;
	
	struct sta_info *psta = NULL;
	struct sta_priv *pstapriv = &padapter->stapriv;
	RTL_WAPI_AP_INFO *pwapiApInfo = &padapter->wapiApInfo;
	RTL_WAPI_STA_INFO *pwapiStaInfo = NULL;

	if (pattrib->encrypt != _SMS4_)
		return _FAIL;

	if (IS_MCAST(pattrib->ra)) {
		if (pwapiApInfo->wapiMcastEnable == false) {
			RTW_INFO("%s: wapiMcastEnable == false\n", __FUNCTION__);
			return _FAIL;
		}

		keyIdx = pwapiApInfo->keyIdx;
		pDataKey = pwapiApInfo->wapiMcastKey[keyIdx].dataKey;
		pMicKey = pwapiApInfo->wapiMcastKey[keyIdx].micKey;
	} else {
		psta = rtw_get_stainfo(pstapriv, pattrib->ra);
		if (!psta) {
			RTW_ERR("%s: rtw_get_stainfo() fail\n", __FUNCTION__);
			return _FAIL;
		}		
		pwapiStaInfo = &psta->wapiStaInfo;
	
		if (pwapiStaInfo->wapiUcastEnable == false) {
			RTW_INFO("%s: wapiUcastEnable == false\n", __FUNCTION__);
			return _FAIL;
		}

		keyIdx = pwapiStaInfo->keyIdx;
		pDataKey = pwapiStaInfo->wapiUcastKey[keyIdx].dataKey;
		pMicKey = pwapiStaInfo->wapiUcastKey[keyIdx].micKey;
	}

	//rtw_dump_buff(pDataKey, WAPI_KEY_LEN, "rtw_sms4_encrypt: data key");
	//rtw_dump_buff(pMicKey, WAPI_KEY_LEN, "rtw_sms4_encrypt: mic key");
	
	for (curfragnum = 0; curfragnum < pattrib->nr_frags; curfragnum++) {
		txreq = &xf->phl_txreq[curfragnum];
		rtw_warn_on(txreq->pkt_cnt != 1);
		pkt_list = (struct rtw_pkt_buf_list *)txreq->pkt_list;
		pframe = pkt_list->vir_addr;
		payload_len = pkt_list->length - pattrib->hdrlen - pattrib->iv_len - pattrib->icv_len;

		//rtw_dump_buff(pframe, pkt_list->length, "rtw_sms4_encrypt: data before encrypt");		
		RTW_INFO("\n%s: wlan hdrlen = %d pattrib->iv_len = %d pattrib->icv_len = %d payload_len = %d keyIdx = %d\n", __FUNCTION__, 
						pattrib->hdrlen, pattrib->iv_len, pattrib->icv_len, payload_len, keyIdx);

		pwapiExt = (WLAN_HDR_WAPI_EXT *)(pframe + pattrib->hdrlen);
		PN = pwapiExt->PN;
		payload = pframe + pattrib->hdrlen + WAPI_EXT_HDR_LEN;

		//rtw_dump_buff(PN, WAPI_PN_LEN, "rtw_sms4_encrypt: PN");

		part1_len = 0;
		_rtw_memset(mic_part1, 0, sizeof(mic_part1));
		rtw_wapi_construct_mic_part1(keyIdx, pframe, pattrib->qos_en, payload_len, mic_part1, &part1_len);
		//rtw_dump_buff(mic_part1, part1_len, "rtw_sms4_encrypt: AAD part1");

		mic_result = pframe + pattrib->hdrlen + WAPI_EXT_HDR_LEN + payload_len;

		rtw_sms4_calculate_mic(pMicKey, PN, mic_part1, part1_len, payload, payload_len, mic_result);
		
		rtw_wapi_sms4_cryption(pDataKey, PN, payload, payload_len + WAPI_MIC_LEN, payload, &encrypt_len);	
	}
	return _SUCCESS;
}

u32	rtw_sms4_decrypt(_adapter *padapter, u8 *precvframe)
{
	u8 keyIdx;
	u8 *pDataKey = NULL, *pMicKey = NULL;

	u16 total_len, payload_len;
	u8 *pframe, *payload;

	u8 mic_part1[64], mic_result[WAPI_MIC_LEN];
	u8 part1_len = 0;
	u16 decrypt_len = 0;

	u8 *recvPN = NULL, *recvMic = NULL;
	WLAN_HDR_WAPI_EXT *pwapiExt = NULL;
	
	struct sta_info *psta = NULL;
	struct sta_priv *pstapriv = &padapter->stapriv;
	RTL_WAPI_AP_INFO *pwapiApInfo = &padapter->wapiApInfo;
	RTL_WAPI_STA_INFO *pwapiStaInfo = NULL;

	struct rx_pkt_attrib *prxattrib = &((union recv_frame *)precvframe)->u.hdr.attrib;
	pframe = (u8 *)((union recv_frame *)precvframe)->u.hdr.rx_data;
	total_len = ((union recv_frame *)precvframe)->u.hdr.len;

	if (prxattrib->encrypt != _SMS4_)
		return _FAIL;

	psta = rtw_get_stainfo(pstapriv , prxattrib->ta);
	if (!psta) {
		RTW_ERR("%s: rtw_get_stainfo() fail\n", __FUNCTION__);
		return _FAIL;
	}	

	if (IS_MCAST(prxattrib->ra)) {
		if (pwapiApInfo->wapiMcastEnable == false) {
			RTW_INFO("%s: wapiMcastEnable == false\n", __FUNCTION__);
			return _FAIL;
		}

		keyIdx = pwapiApInfo->keyIdx;
		pDataKey = pwapiApInfo->wapiMcastKey[keyIdx].dataKey;
		pMicKey = pwapiApInfo->wapiMcastKey[keyIdx].micKey;
	} else {				
		pwapiStaInfo = &psta->wapiStaInfo;	
		if (pwapiStaInfo->wapiUcastEnable == false) {
			RTW_INFO("%s: wapiUcastEnable == false\n", __FUNCTION__);
			return _FAIL;
		}

		keyIdx = pwapiStaInfo->keyIdx;
		pDataKey = pwapiStaInfo->wapiUcastKey[keyIdx].dataKey;
		pMicKey = pwapiStaInfo->wapiUcastKey[keyIdx].micKey;
	}	

	pwapiExt = (WLAN_HDR_WAPI_EXT *)(pframe + prxattrib->hdrlen);

	if (pwapiExt->keyIdx != keyIdx) {
		RTW_INFO("%s: keyIdx (%d) in received packet is invalid\n", __FUNCTION__, pwapiExt->keyIdx);
		return _FAIL;
	}

	//rtw_dump_buff(pDataKey, WAPI_KEY_LEN, "rtw_sms4_decrypt: data key");
	//rtw_dump_buff(pMicKey, WAPI_KEY_LEN, "rtw_sms4_decrypt: mic key");

	//rtw_dump_buff(pframe, total_len, "rtw_sms4_decrypt: data before decrypt");

	recvPN = pwapiExt->PN;

	//rtw_dump_buff(recvPN, WAPI_PN_LEN, "rtw_sms4_decrypt: recvPN");

	payload = pframe + prxattrib->hdrlen + WAPI_EXT_HDR_LEN;
	payload_len = total_len - prxattrib->hdrlen - WAPI_EXT_HDR_LEN;
	recvMic = pframe + total_len - WAPI_MIC_LEN;

	RTW_INFO("\n%s: wlan hdrlen = %d payload_len = %d keyIdx = %d\n", __FUNCTION__, prxattrib->hdrlen, payload_len, keyIdx);	

	rtw_wapi_sms4_cryption(pDataKey, recvPN, payload, payload_len, payload, &decrypt_len);
	
	if (decrypt_len != payload_len) {
		RTW_INFO("%s: decrypt_len != payload_len\n", __FUNCTION__);
		return _FAIL;	
	}

	payload_len -= WAPI_MIC_LEN;
	rtw_wapi_construct_mic_part1(keyIdx, pframe, prxattrib->qos, payload_len, mic_part1, &part1_len);
	//rtw_dump_buff(mic_part1, part1_len, "rtw_sms4_decrypt: AAD part1");

	//local calculate MIC
	rtw_sms4_calculate_mic(pMicKey, recvPN, mic_part1, part1_len, payload, payload_len, mic_result);

	//compare MIC
	if (_rtw_memcmp(mic_result, recvMic, WAPI_MIC_LEN) == _FALSE) {
		RTW_INFO("%s: check MIC fail\n", __FUNCTION__);
		//rtw_dump_buff(recvMic, WAPI_MIC_LEN, "rtw_sms4_decrypt: recvMic");
		//rtw_dump_buff(mic_result, WAPI_MIC_LEN, "rtw_sms4_decrypt: mic_result");

		RTW_INFO_DUMP("rtw_sms4_decrypt: data before decrypt", pframe, prxattrib->hdrlen + 18);
		return _FAIL;		
	} else {
		RTW_INFO("%s: check MIC success\n", __FUNCTION__);

		//rtw_dump_buff(pframe, total_len, "rtw_sms4_decrypt: data after decrypt");
	}
	
	return _SUCCESS;
}

u32	rtw_wapi_gcm_sm4_cryption(u8 *key, u8 *iv, u8 *aad, u16 aadLength,
                  u8 *pData, u16 dataLength, u8 *output, u8 *mic, u32 CryptFlag)
{
	GCM128_CONTEXT ctx;
	int ret = _SUCCESS;

	if( key==NULL || iv==NULL || aad==NULL || pData==NULL || output==NULL || mic==NULL ){
		RTW_INFO("%s: argv is NULL!!!\n", __FUNCTION__);
		printk("argv is null!!!\n");
		return _FAIL;
	}

	CRYPTO_gcm128_init(&ctx, (void *)key, (block128_f)GCM_SM4Crypt);
	CRYPTO_gcm128_setiv(&ctx, iv, 12);
	CRYPTO_gcm128_aad(&ctx, aad, aadLength);
	if(CryptFlag == WAPI_ENCRYPT){
		CRYPTO_gcm128_encrypt(&ctx, pData, output, dataLength);
		//DUMP_DATA("encrypt out data is",output,dataLength);
		CRYPTO_gcm128_tag(&ctx, mic, 16);
		//DUMP_DATA("encrypt mic tag is",mic,16);
	}
	else if(CryptFlag == WAPI_DECRYPT){
		CRYPTO_gcm128_decrypt(&ctx, pData, output, dataLength);
		//DUMP_DATA("decrypt out data is",output,dataLength);
		if(0 != CRYPTO_gcm128_finish(&ctx, mic, 16))
			ret = _FAIL;
		else
			ret = _SUCCESS;
		//DUMP_DATA("decrypt mic tag is",ctx.Xi.c,16);
	}

	return ret;
}

u32	rtw_gcm_sm4_encrypt(_adapter *padapter, u8 *pxmitframe)
{
	u8 keyIdx;
	u8 *pDataKey = NULL;
	u8 *pMicKey = NULL;

	u16 curfragnum, payload_len;
	struct rtw_xmit_req *txreq = NULL;
	struct rtw_pkt_buf_list *pkt_list = NULL;
	u8 *pframe, *payload, *iv, *PN, *mic_result;

	u8 mic_part1[64];
	u8 part1_len = 0;
	u16 encrypt_len = 0;
	
	struct xmit_frame *xf = (struct xmit_frame *)pxmitframe;
	struct pkt_attrib *pattrib = &xf->attrib;
	WLAN_HDR_WAPI_EXT *pwapiExt = NULL;
	
	struct sta_info *psta = NULL;
	struct sta_priv *pstapriv = &padapter->stapriv;
	RTL_WAPI_AP_INFO *pwapiApInfo = &padapter->wapiApInfo;
	RTL_WAPI_STA_INFO *pwapiStaInfo = NULL;

	if (pattrib->encrypt != _GCM_SM4_)
		return _FAIL;

	if (IS_MCAST(pattrib->ra)) {
		if (pwapiApInfo->wapiMcastEnable == false) {
			RTW_INFO("%s: wapiMcastEnable == false\n", __FUNCTION__);
			return _FAIL;
		}

		keyIdx = pwapiApInfo->keyIdx;
		pDataKey = pwapiApInfo->wapiMcastKey[keyIdx].dataKey;
		pMicKey = pwapiApInfo->wapiMcastKey[keyIdx].micKey;
	} else {
		psta = rtw_get_stainfo(pstapriv, pattrib->ra);
		if (!psta) {
			RTW_ERR("%s: rtw_get_stainfo() fail\n", __FUNCTION__);
			return _FAIL;
		}		
		pwapiStaInfo = &psta->wapiStaInfo;
	
		if (pwapiStaInfo->wapiUcastEnable == false) {
			RTW_INFO("%s: wapiUcastEnable == false\n", __FUNCTION__);
			return _FAIL;
		}

		keyIdx = pwapiStaInfo->keyIdx;
		pDataKey = pwapiStaInfo->wapiUcastKey[keyIdx].dataKey;
		pMicKey = pwapiStaInfo->wapiUcastKey[keyIdx].micKey;
	}

	//rtw_dump_buff(pDataKey, WAPI_KEY_LEN, "rtw_gcm_sm4_encrypt: data key");
	//rtw_dump_buff(pMicKey, WAPI_KEY_LEN, "rtw_gcm_sm4_encrypt: mic key");
	
	for (curfragnum = 0; curfragnum < pattrib->nr_frags; curfragnum++) {
		txreq = &xf->phl_txreq[curfragnum];
		rtw_warn_on(txreq->pkt_cnt != 1);
		pkt_list = (struct rtw_pkt_buf_list *)txreq->pkt_list;
		pframe = pkt_list->vir_addr;
		payload_len = pkt_list->length - pattrib->hdrlen - pattrib->iv_len - pattrib->icv_len;

		//rtw_dump_buff(pframe, pkt_list->length, "rtw_sms4_encrypt: data before encrypt");		
		RTW_INFO("\n%s: wlan hdrlen = %d pattrib->iv_len = %d pattrib->icv_len = %d payload_len = %d keyIdx = %d\n", __FUNCTION__, 
						pattrib->hdrlen, pattrib->iv_len, pattrib->icv_len, payload_len, keyIdx);

		pwapiExt = (WLAN_HDR_WAPI_EXT *)(pframe + pattrib->hdrlen);
		PN = pwapiExt->PN;
		payload = pframe + pattrib->hdrlen + WAPI_EXT_HDR_LEN;

		//rtw_dump_buff(PN, WAPI_PN_LEN, "rtw_gcm_sm4_encrypt: PN");

		part1_len = 0;
		_rtw_memset(mic_part1, 0, sizeof(mic_part1));
		rtw_wapi_construct_mic_part1(keyIdx, pframe, pattrib->qos_en, payload_len, mic_part1, &part1_len);
		//rtw_dump_buff(mic_part1, part1_len, "rtw_sms4_encrypt: AAD part1");

		mic_result = pframe + pattrib->hdrlen + WAPI_EXT_HDR_LEN + payload_len;

		rtw_wapi_gcm_sm4_cryption(pDataKey, PN, mic_part1, part1_len, payload, payload_len, payload, mic_result, WAPI_ENCRYPT);
	}	
	return _SUCCESS;
}

u32	rtw_gcm_sm4_decrypt(_adapter *padapter, u8 *precvframe)
{
	u8 keyIdx;
	u8 *pDataKey = NULL, *pMicKey = NULL;

	u16 total_len, payload_len;
	u8 *pframe, *payload;

	u8 mic_part1[64], mic_result[WAPI_MIC_LEN];
	u8 part1_len = 0;
	u16 decrypt_len = 0;

	u8 *recvPN = NULL, *recvMic = NULL;
	WLAN_HDR_WAPI_EXT *pwapiExt = NULL;
	
	struct sta_info *psta = NULL;
	struct sta_priv *pstapriv = &padapter->stapriv;
	RTL_WAPI_AP_INFO *pwapiApInfo = &padapter->wapiApInfo;
	RTL_WAPI_STA_INFO *pwapiStaInfo = NULL;

	struct rx_pkt_attrib *prxattrib = &((union recv_frame *)precvframe)->u.hdr.attrib;
	pframe = (u8 *)((union recv_frame *)precvframe)->u.hdr.rx_data;
	total_len = ((union recv_frame *)precvframe)->u.hdr.len;

	if (prxattrib->encrypt != _GCM_SM4_)
		return _FAIL;

	psta = rtw_get_stainfo(pstapriv , prxattrib->ta);
	if (!psta) {
		RTW_ERR("%s: rtw_get_stainfo() fail\n", __FUNCTION__);
		return _FAIL;
	}	

	if (IS_MCAST(prxattrib->ra)) {
		if (pwapiApInfo->wapiMcastEnable == false) {
			RTW_INFO("%s: wapiMcastEnable == false\n", __FUNCTION__);
			return _FAIL;
		}

		keyIdx = pwapiApInfo->keyIdx;
		pDataKey = pwapiApInfo->wapiMcastKey[keyIdx].dataKey;
		pMicKey = pwapiApInfo->wapiMcastKey[keyIdx].micKey;
	} else {				
		pwapiStaInfo = &psta->wapiStaInfo;	
		if (pwapiStaInfo->wapiUcastEnable == false) {
			RTW_INFO("%s: wapiUcastEnable == false\n", __FUNCTION__);
			return _FAIL;
		}

		keyIdx = pwapiStaInfo->keyIdx;
		pDataKey = pwapiStaInfo->wapiUcastKey[keyIdx].dataKey;
		pMicKey = pwapiStaInfo->wapiUcastKey[keyIdx].micKey;
	}	

	pwapiExt = (WLAN_HDR_WAPI_EXT *)(pframe + prxattrib->hdrlen);

	if (pwapiExt->keyIdx != keyIdx) {
		RTW_INFO("%s: keyIdx (%d) in received packet is invalid\n", __FUNCTION__, pwapiExt->keyIdx);
		return _FAIL;
	}

	//rtw_dump_buff(pDataKey, WAPI_KEY_LEN, "rtw_gcm_sm4_decrypt: data key");
	//rtw_dump_buff(pMicKey, WAPI_KEY_LEN, "rtw_gcm_sm4_decrypt: mic key");


	recvPN = pwapiExt->PN;

	//rtw_dump_buff(recvPN, WAPI_PN_LEN, "rtw_gcm_sm4_decrypt: recvPN");

	payload = pframe + prxattrib->hdrlen + WAPI_EXT_HDR_LEN;
	payload_len = total_len - prxattrib->hdrlen - WAPI_EXT_HDR_LEN;
	recvMic = pframe + total_len - WAPI_MIC_LEN;

	RTW_INFO("\n%s: wlan hdrlen = %d payload_len = %d keyIdx = %d\n", __FUNCTION__, prxattrib->hdrlen, payload_len, keyIdx);	

	payload_len -= WAPI_MIC_LEN;
	rtw_wapi_construct_mic_part1(keyIdx, pframe, prxattrib->qos, payload_len, mic_part1, &part1_len);
	//rtw_dump_buff(mic_part1, part1_len, "rtw_gcm_sm4_decrypt: AAD part1");


	if(rtw_wapi_gcm_sm4_cryption(pDataKey, recvPN, mic_part1, part1_len, payload, payload_len, payload, recvMic, WAPI_DECRYPT) == _FAIL){
		RTW_INFO("%s: check MIC fail\n", __FUNCTION__);
		RTW_INFO_DUMP("rtw_gcm_sm4_decrypt: data before decrypt", pframe, prxattrib->hdrlen + 18);
		return _FAIL;
	}
	else{
		RTW_INFO("%s: check MIC success\n", __FUNCTION__);
		//rtw_dump_buff(pframe, total_len, "rtw_gcm_sm4_decrypt: data after decrypt");	
	}
	
	return _SUCCESS;
}

u32 rtw_wapi_gcm_sm4_test(u8 index)
{
#ifdef WAPI_GCM_SM4_DEBUG
	unsigned char out[1024]={0},tag[16]={0};
	u8 *key,*iv,*aad,*pdata,*cdata,*mictag;
	u16 aad_len=0,pdata_len=0;

	if(index >= TEST_TABLE_NUM){
		printk("test table index error!\n");
		return -1;
	}
	else
		printk("test table%d\n",index);
	key = KEY[index];
	iv = IV[index];
	aad = AAD[index];
	pdata = PDATA[index];
	cdata = CDATA[index];
	mictag = MICTAG[index];
	switch(index){
		case 0:
			aad_len = sizeof(aad0);
			pdata_len = sizeof(pdata0);
			break;
		case 1:
			aad_len = sizeof(aad1);
			pdata_len = sizeof(pdata1);
			break;
		case 2:
			aad_len = sizeof(aad2);
			pdata_len = sizeof(pdata2);
			break;
		case 3:
			aad_len = sizeof(aad3);
			pdata_len = sizeof(pdata3);
			break;
		case 4:
			aad_len = sizeof(aad4);
			pdata_len = sizeof(pdata4);
			break;
		case 5:
			aad_len = sizeof(aad5);
			pdata_len = sizeof(pdata5);
			break;
		case 6:
			aad_len = sizeof(aad6);
			pdata_len = sizeof(pdata6);
			break;
		case 7:
			aad_len = sizeof(aad7);
			pdata_len = sizeof(pdata7);
			break;
		case 8:
			aad_len = sizeof(aad8);
			pdata_len = sizeof(pdata8);
			break;
		case 9:
			aad_len = sizeof(aad9);
			pdata_len = sizeof(pdata9);
			break;
		case 10:
			aad_len = sizeof(aad10);
			pdata_len = sizeof(pdata10);
			break;
		case 11:
			aad_len = sizeof(aad11);
			pdata_len = sizeof(pdata11);
			break;
		case 12:
			aad_len = sizeof(aad12);
			pdata_len = sizeof(pdata12);
			break;
		case 13:
			aad_len = sizeof(aad13);
			pdata_len = sizeof(pdata13);
			break;
		case 14:
			aad_len = sizeof(aad14);
			pdata_len = sizeof(pdata14);
			break;
		default:
			break;
	}

	rtw_wapi_gcm_sm4_cryption(key, iv, aad, aad_len, pdata, pdata_len, out, tag, WAPI_ENCRYPT);
	if(0==memcmp(tag,mictag,sizeof(mictag)))
		printk("encrypt mic success!\n");
	else
		printk("encrypt mic error!\n");

	if(0==memcmp(out,cdata,pdata_len))
		printk("encrypt data success!\n");
	else
		printk("encrypt data error!\n");
	
	DUMP_DATA("encrypt data is",out,pdata_len);
	DUMP_DATA("encrypt mic is",tag,16);


	if(rtw_wapi_gcm_sm4_cryption(key, iv, aad, aad_len, cdata, pdata_len, out, mictag, WAPI_DECRYPT) == _SUCCESS) 
		printk("decrypt mic success!\n");
	else
		printk("decrypt mic fail!\n");
	if(0==memcmp(out,pdata,pdata_len))
		printk("decrypt data success!\n");
	else
		printk("decrypt data error!\n");
	DUMP_DATA("decrypt data is",out,pdata_len);

#endif
	return 0;
}


#endif
