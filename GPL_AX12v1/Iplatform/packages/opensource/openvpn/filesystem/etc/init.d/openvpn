#!/bin/sh /etc/rc.common
# Copyright (C) 2008-2013 OpenWrt.org
# Copyright (C) 2008 Jo-Philipp Wich
# This is free software, licensed under the GNU General Public License v2.
# See /LICENSE for more information.

START=90
STOP=10

SERVICE_DAEMONIZE=1
SERVICE_WRITE_PID=1

OPENVPN_SECRETS=/var/etc/openvpn-psw-file
EXTRA_COMMANDS="up down"
PUBLIC_DNS_SERVER="8.8.8.8"
LIST_SEP="
"

get_network() {
	local ipaddr="$1"
	local netmask="$2"

	echo "$ipaddr-$netmask" | awk -F '[.-]' '{ ip = lshift($1, 24) + lshift($2, 16) + lshift($3, 8) + $4; \
		mask = lshift($5, 24) + lshift($6, 16) + lshift($7, 8) + $8; \
		net = and(ip, mask); \
		printf("%d.%d.%d.%d", and(rshift(net, 24), 255), and(rshift(net, 16), 255), and(rshift(net, 8), 255), and(net, 255)); \
	}'
}

append_param() {
	local s="$1"
	local v="$2"
	case "$v" in
		*_*_*_*) v=${v%%_*}-${v#*_}; v=${v%%_*}-${v#*_}; v=${v%%_*}-${v#*_} ;;
		*_*_*)   v=${v%%_*}-${v#*_}; v=${v%%_*}-${v#*_} ;;
		*_*)     v=${v%%_*}-${v#*_} ;;
	esac
	echo -n "$v" >> "/var/etc/openvpn-$s.conf"
	return 0
}

append_bools() {
	local p; local v; local s="$1"; shift
	for p in "$@"; do
		config_get_bool v "$s" "$p"
		[ "$v" = 1 ] && append_param "$s" "$p" && echo >> "/var/etc/openvpn-$s.conf"
	done
}

append_params() {
	local p; local v; local s="$1"; shift
	for p in "$@"; do
		config_get v "$s" "$p"
		IFS="$LIST_SEP"
		if [ "$p" == "server" ]; then
		    local ipaddr=${v%% *}
		    local mask=${v##* }
		    local network="$(get_network $ipaddr $mask)"
		    [ -n "$v" ] && echo "$p $network $mask" >> "/var/etc/openvpn-$s.conf"
        elif [ "$p" == "server_bridge" ]; then
            echo "server-bridge" >> "/var/etc/openvpn-$s.conf"
        elif [ "$p" == "dev" ]; then
            # tunS for tun, tapS for tap
            echo "dev ${v}S" >> "/var/etc/openvpn-$s.conf"
		else
		    for v in $v; do
			    [ -n "$v" ] && append_param "$s" "$p" && echo " $v" >> "/var/etc/openvpn-$s.conf"
		    done
		fi
		unset IFS
	done
}

append_access() {
	local s="$1"
	local access=
	local server=
    local dev="tun"
	local ipaddr="`uci get network.lan.ipaddr`"
	local netmask="`uci get network.lan.netmask`"
	local network=

	# added by CCy for C2200, to solve the openvpn low throughput problem temporarily
	echo "sndbuf $((655350/2))" >> "/var/etc/openvpn-$s.conf"
	# add ended by CCy

	# default gateway
	config_get access "$s" "access" "home"
	config_get dev "$s" "dev"
	if [ X$dev == "X" ]; then
		dev="tun"
	fi
	if [ "$access" == "internet" ]; then
		# case client doesn't have gateway route
        if [ "$dev" == "tun" ]; then
		    echo "push \"route 0.0.0.0 0.0.0.0\"" >> "/var/etc/openvpn-$s.conf"
        fi
		# redirect gateway route
		echo "push \"redirect-gateway def1\"" >> "/var/etc/openvpn-$s.conf"
	fi

    if [ "$dev" == "tun" ]; then
    	# push route lan network whenever "$access" equals "internet" or "home"
    	network="$(get_network $ipaddr $netmask)"
    	echo "push \"route $network $netmask\"" >> "/var/etc/openvpn-$s.conf"
    	config_get server "$s" "server" "0.0.0.0"
    	if [ "$server" != "0.0.0.0" ]; then
    		ipaddr=${server%% *}
    		netmask=${server##* }
    		network="$(get_network $ipaddr $netmask)"
    		echo "push \"route $network $netmask\"" >> "/var/etc/openvpn-$s.conf"

    		#push dns
    		serverip=$(echo $network | awk -F"." '{print $1 "." $2 "." $3 ".1"}')
    		echo "push \"dhcp-option DNS $serverip\"" >> "/var/etc/openvpn-$s.conf"
    		echo "push \"dhcp-option DNS $PUBLIC_DNS_SERVER\"" >> "/var/etc/openvpn-$s.conf"
    	fi
    fi
}

section_enabled() {
	local wanproto=$(uci get network.wan.wan_type)
	[ "$wanproto" = "dslite" ] && {
		echo "openvpn server not support dial type dslite" > /dev/console
		return 1
	}
	config_get_bool enable  "$1" 'enable'  0
	config_get_bool enabled "$1" 'enabled' 0
	[ $enable -gt 0 ] || [ $enabled -gt 0 ]
}

setup_login() {
	local section="$1"

	config_get username "$section" username
	config_get password "$section" password
	[ -n "$username" ] || return 0
	[ -n "$password" ] || return 0

	echo "$username $password" >> $OPENVPN_SECRETS
}

start_instance() {
	local s="$1"
	local small_mem

	section_enabled "$s" || return 1

	[ ! -d "/var/run" ] && mkdir -p "/var/run"
	[ ! -d "/var/etc" ] && mkdir -p "/var/etc"
	[ -f "/var/etc/openvpn-$s.conf" ] && rm "/var/etc/openvpn-$s.conf"

	local proto="udp"
	local port="1194"
	local access="home"
    local dev="tun"

	config_get proto "server" "proto"
	config_get port "server" "port"
	config_get access "server" "access"
    config_get dev "server" "dev"
	if [ X$dev == "X" ]; then
		dev="tun"
	fi

	fw openvpn_access $proto $port $access $dev

	grep -wq "tun" /proc/modules || /sbin/insmod tun 2>&- >&-

    if [ "$dev" == "tun" ] ; then
        # tun mode specific params
	    append_params "$s" \
            server ifconfig_pool  ifconfig_pool_persist

    elif [ "$dev" == "tap" ]; then
        # tap mode
        # add tap bridge device
        openvpn --mktun --dev tapS
        brctl addif br-lan tapS
        ifconfig tapS 0.0.0.0 promisc up

        # tap mode specific params
	    append_params "$s" \
            server_bridge
    else
        echo "error dev type $dev" > /dev/console
	    /sbin/rmmod tun 2>&- >&-
        return 1
    fi

	# append flags
	append_bools "$s" \
		auth_nocache auth_retry auth_user_pass_optional bind ccd_exclusive client client_cert_not_required \
		client_to_client comp_noadapt disable \
		disable_occ down_pre duplicate_cn fast_io float http_proxy_retry \
		ifconfig_noexec ifconfig_nowarn ifconfig_pool_linear management_forget_disconnect management_hold \
		management_query_passwords management_signal mktun mlock mtu_test multihome mute_replay_warnings \
		nobind no_iv no_name_remapping no_replay opt_verify passtos persist_key persist_local_ip \
		persist_remote_ip persist_tun ping_timer_rem pull push_reset \
		remote_random rmtun route_noexec route_nopull single_session socks_proxy_retry \
		suppress_timestamps tcp_nodelay test_crypto tls_client tls_exit tls_server \
		tun_ipv6 up_delay up_restart username_as_common_name

	# append params
	append_params "$s" \
		cd askpass auth auth_user_pass auth_user_pass_verify bcast_buffers ca cert \
		chroot cipher client_config_dir client_connect client_disconnect comp_lzo connect_freq \
		connect_retry connect_timeout connect_retry_max crl_verify dev dev_node dev_type dh \
		echo engine explicit_exit_notify fragment group hand_window hash_size \
		http_proxy http_proxy_option http_proxy_timeout ifconfig \
		ifconfig_push inactive ipchange iroute keepalive \
		key key_method keysize learn_address link_mtu lladdr local log log_append \
		lport management management_log_cache max_clients \
		max_routes_per_client mode mssfix mtu_disc mute nice ns_cert_type ping \
		ping_exit ping_restart pkcs12 plugin port port_share prng proto rcvbuf \
		redirect_gateway remap_usr1 remote remote_cert_eku remote_cert_ku remote_cert_tls \
		reneg_bytes reneg_pkts reneg_sec \
		replay_persist replay_window resolv_retry route route_delay route_gateway \
		route_metric route_up rport script_security secret setenv shaper sndbuf \
		socks_proxy status status_version syslog tcp_queue_limit tls_auth \
		tls_cipher tls_remote tls_timeout tls_verify tmp_dir topology tran_window \
		tun_mtu tun_mtu_extra txqueuelen user verb down push up

	# handle client access type
	append_access "$s"

	SERVICE_PID_FILE="/var/run/openvpn-$s.pid"
	service_start /usr/sbin/openvpn --syslog "openvpn($s)" --writepid "$SERVICE_PID_FILE" --config "/var/etc/openvpn-$s.conf"
}

stop_instance() {
	local s="$1"

	# section_enabled "$s" || return 1

	local proto="udp"
	local port="1194"
	local access="home"
	local openvpn_client_enabled="off"
	local vpntype="none"
    local dev="tun"

	config_get proto "server" "proto"
	config_get port "server" "port"
	config_get access "server" "access"
	config_get dev "server" "dev"

	if [ X$dev == "X" ]; then
		dev="tun"
	fi

	fw openvpn_block $proto $port $access $dev

	SERVICE_PID_FILE="/var/run/openvpn-$s.pid"
	service_stop /usr/sbin/openvpn

	if [ $dev == "tap" ] ; then
        openvpn --rmtun --dev tapS
    fi
	if [ -f "/etc/config/vpn" ]; then
		config_load vpn
		config_get openvpn_client_enabled "client" "enabled" "off"
		config_get vpntype "client" "vpntype" "none"
	fi
	if [ $openvpn_client_enabled == "on" -a $vpntype == "openvpn"  ];then
		echo "openvpn client is on, do not rmmod tun" > /dev/console
	else
		echo "rmmod openvpn tun in server" > /dev/console
		/sbin/rmmod tun 2>&- >&-
	fi
}

reload_instance() {
	local s="$1"

	section_enabled "$s" || return 1

	SERVICE_PID_FILE="/var/run/openvpn-$s.pid"
	service_reload /usr/sbin/openvpn
}

start() {
	config_load 'openvpn'
	: > $OPENVPN_SECRETS
	config_foreach setup_login login
	config_foreach start_instance 'openvpn'
}

stop() {
	config_load 'openvpn'
	config_foreach stop_instance 'openvpn'
}

reload() {
	config_load 'openvpn'
	config_foreach reload_instance 'openvpn'
}

up() {
	local exists
	local instance
	: > $OPENVPN_SECRETS
	config_load 'openvpn'
	for instance in "$@"; do
		config_get exists "$instance" 'TYPE'
		if [ "$exists" == "openvpn" ]; then
			start_instance "$instance"
		else
			if [ "$exists" == "login" ]; then
			    setup_login "$instance"
			fi
		fi
	done
}

down() {
	local exists
	local instance
	config_load 'openvpn'
	for instance in "$@"; do
		config_get exists "$instance" 'TYPE'
		if [ "$exists" == "openvpn" ]; then
			stop_instance "$instance"
		fi
	done
}
